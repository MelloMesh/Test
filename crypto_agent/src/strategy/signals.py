"""
Signal dataclass for trade signals generated by the strategy.
"""

from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class Signal:
    """
    A trade signal generated by the golden pocket strategy.

    Contains all information needed for the risk manager and order executor
    to process the trade.
    """

    direction: str                      # "LONG" or "SHORT"
    confidence: float                   # 0.0 to 1.0
    risk_pct: float                     # 0.01 or 0.02 based on confluence
    entry_price: float                  # Current market price at signal
    stop_loss: float                    # Below/above 0.886 fib, max 5% from entry
    take_profits: list[dict]            # [{'level': 0.5, 'price': X, 'pct': 0.3}, ...]
    timeframe: str                      # "15m" or "30m"
    symbol: str                         # "BTC/USDT:USDT"
    fib_levels: dict[float, float]      # Full fib level map for this swing
    swing_high: float                   # The swing high used to draw fibs
    swing_low: float                    # The swing low used to draw fibs
    rsi_values: dict                    # RSI snapshot: current, peak, prior_peak
    divergence_type: str                # "bullish" or "bearish"
    confluence_factors: list[str]       # Which factors contributed to risk_pct
    timestamp: datetime                 # When signal was generated
    reason: str                         # Human-readable explanation

    def __str__(self) -> str:
        return (
            f"Signal({self.direction} {self.symbol} @ {self.entry_price:.2f} | "
            f"SL={self.stop_loss:.2f} | risk={self.risk_pct*100:.1f}% | "
            f"conf={self.confidence:.2f} | {self.reason})"
        )

    @property
    def stop_distance_pct(self) -> float:
        """Percentage distance from entry to stop loss."""
        return abs(self.entry_price - self.stop_loss) / self.entry_price

    @property
    def risk_reward_ratio(self) -> float | None:
        """R:R to first take profit level."""
        if not self.take_profits:
            return None
        tp1_price = self.take_profits[0]["price"]
        reward = abs(tp1_price - self.entry_price)
        risk = abs(self.entry_price - self.stop_loss)
        if risk == 0:
            return None
        return reward / risk
