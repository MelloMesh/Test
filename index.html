<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelloScan — Bybit Futures Screener</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0e13;
  --bg-secondary: #111820;
  --bg-tertiary: #1a2230;
  --bg-hover: #182030;
  --bg-row-alt: #0d1219;
  --border-color: #1e2a3a;
  --border-subtle: #161f2c;
  --text-primary: #d1d5db;
  --text-secondary: #7a8a9e;
  --text-muted: #3e4f65;
  --green: #22c55e;
  --green-bright: #4ade80;
  --green-dim: rgba(34,197,94,0.12);
  --green-bg: rgba(34,197,94,0.08);
  --red: #ef4444;
  --red-bright: #f87171;
  --red-dim: rgba(239,68,68,0.12);
  --red-bg: rgba(239,68,68,0.08);
  --yellow: #eab308;
  --yellow-dim: rgba(234,179,8,0.12);
  --blue: #3b82f6;
  --blue-dim: rgba(59,130,246,0.12);
  --blue-muted: rgba(59,130,246,0.06);
  --orange: #f59e0b;
  --font-mono: 'JetBrains Mono', 'SF Mono', 'Cascadia Code', 'Fira Code', Consolas, monospace;
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  --row-height: 40px;
}

html, body {
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-size: 13px;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
}

/* ── Layout ── */
.app-layout { display: flex; flex-direction: column; height: 100vh; }

/* ── Refresh stripe ── */
.refresh-stripe {
  position: fixed; top: 0; left: 0; right: 0; height: 2px; z-index: 999;
  background: transparent; overflow: hidden;
}
.refresh-stripe.active { background: var(--bg-tertiary); }
.refresh-stripe .stripe-bar {
  height: 100%; width: 0%;
  background: linear-gradient(90deg, var(--blue), #60a5fa);
  transition: width 0.4s ease; border-radius: 0 1px 1px 0;
}
.refresh-stripe.indeterminate .stripe-bar {
  width: 30%; animation: stripe-slide 1.5s ease-in-out infinite;
}
@keyframes stripe-slide {
  0% { transform: translateX(-100%); } 100% { transform: translateX(400%); }
}

/* ── Header ── */
.header {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 10px 16px; display: flex; align-items: center; gap: 12px;
  flex-wrap: wrap; z-index: 100;
}
.brand { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.brand-icon { color: var(--blue); flex-shrink: 0; }
.brand-name {
  font-size: 15px; font-weight: 800; color: var(--text-primary);
  font-family: var(--font-mono); letter-spacing: 0.5px;
}
.brand-name span { color: var(--blue); }
.brand-sub {
  font-size: 10px; color: var(--text-muted); font-family: var(--font-sans);
  margin-left: 4px; font-weight: 400; letter-spacing: 0.3px;
}
.header-divider { width: 1px; height: 24px; background: var(--border-color); }

/* ── Search ── */
.search-box { position: relative; flex: 0 0 180px; }
.search-box input {
  width: 100%; background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 5px 10px 5px 28px; color: var(--text-primary);
  font-size: 12px; font-family: var(--font-mono); outline: none;
  transition: border-color 0.2s;
}
.search-box input:focus { border-color: var(--blue); }
.search-box input::placeholder { color: var(--text-muted); }
.search-box::before {
  content: '\1F50D'; position: absolute; left: 8px; top: 50%;
  transform: translateY(-50%); font-size: 11px; opacity: 0.4;
}

/* ── Filter pills ── */
.filter-bar {
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap; flex: 1;
}
.filter-pill {
  background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 4px 10px; color: var(--text-secondary);
  font-size: 11px; cursor: pointer; transition: all 0.15s; white-space: nowrap;
  font-family: var(--font-sans); font-weight: 500;
  display: flex; align-items: center; gap: 5px;
}
.filter-pill:hover {
  border-color: var(--text-muted); color: var(--text-primary);
  background: var(--bg-tertiary);
}
.filter-pill.active {
  background: var(--blue-dim); border-color: var(--blue); color: var(--blue);
}
.filter-pill.active .pill-x { display: inline-flex; }
.pill-x {
  display: none; width: 14px; height: 14px; align-items: center;
  justify-content: center; border-radius: 50%; font-size: 10px; line-height: 1;
  background: rgba(59,130,246,0.2); color: var(--blue); margin-left: 2px;
}
.filter-dropdown {
  position: relative; display: inline-flex;
}
.filter-dropdown-btn {
  background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 4px 10px; color: var(--text-secondary);
  font-size: 11px; cursor: pointer; transition: all 0.15s; white-space: nowrap;
  font-family: var(--font-sans); font-weight: 500;
  display: flex; align-items: center; gap: 5px;
}
.filter-dropdown-btn:hover {
  border-color: var(--text-muted); color: var(--text-primary);
  background: var(--bg-tertiary);
}
.filter-dropdown-btn.active {
  background: var(--blue-dim); border-color: var(--blue); color: var(--blue);
}
.filter-dropdown-btn .dd-arrow {
  font-size: 8px; opacity: 0.6; margin-left: 2px;
}
.filter-dropdown-menu {
  display: none; position: fixed;
  background: var(--bg-secondary); border: 1px solid var(--border-color);
  border-radius: 6px; padding: 4px 0; z-index: 9999; min-width: 130px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}
.filter-dropdown-menu.open { display: block; }
.filter-dropdown-menu button {
  display: block; width: 100%; text-align: left; padding: 6px 12px;
  background: none; border: none; color: var(--text-secondary);
  font-size: 11px; font-family: var(--font-sans); cursor: pointer;
  transition: all 0.1s;
}
.filter-dropdown-menu button:hover {
  background: var(--bg-tertiary); color: var(--text-primary);
}
.filter-dropdown-menu button.selected {
  color: var(--blue); font-weight: 600;
}
.filter-clear {
  background: none; border: 1px solid transparent; border-radius: 4px;
  padding: 4px 8px; color: var(--text-muted); font-size: 11px; cursor: pointer;
  font-family: var(--font-sans); transition: all 0.15s; display: none;
}
.filter-clear.visible { display: inline-flex; }
.filter-clear:hover { color: var(--red); border-color: var(--red-dim); }
.filter-result-count {
  font-size: 11px; color: var(--text-muted); font-family: var(--font-mono);
  margin-left: 4px; font-variant-numeric: tabular-nums;
}

/* ── Column picker ── */
.col-picker-wrapper { position: relative; }
.col-picker-btn {
  background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 4px 8px; color: var(--text-secondary);
  font-size: 11px; cursor: pointer; transition: all 0.15s;
  display: flex; align-items: center; gap: 4px;
  font-family: var(--font-sans); font-weight: 500;
}
.col-picker-btn:hover { border-color: var(--text-muted); color: var(--text-primary); }
.col-picker-btn svg { width: 14px; height: 14px; opacity: 0.7; }
.col-picker-dropdown {
  display: none; position: absolute; top: calc(100% + 4px); right: 0;
  background: var(--bg-secondary); border: 1px solid var(--border-color);
  border-radius: 6px; padding: 6px 0; min-width: 180px; z-index: 200;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); max-height: 400px; overflow-y: auto;
}
.col-picker-dropdown.open { display: block; }
.col-picker-dropdown .picker-header {
  padding: 6px 12px 8px; font-size: 10px; text-transform: uppercase;
  letter-spacing: 0.5px; color: var(--text-muted); font-weight: 600;
  border-bottom: 1px solid var(--border-color); margin-bottom: 4px;
}
.col-picker-item {
  display: flex; align-items: center; gap: 8px; padding: 5px 12px;
  cursor: pointer; transition: background 0.1s; font-size: 12px;
  color: var(--text-secondary); position: relative;
}
.col-picker-item:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.col-picker-item.disabled { opacity: 0.4; cursor: default; }
.col-picker-item input[type="checkbox"] {
  appearance: none; -webkit-appearance: none; width: 14px; height: 14px;
  border: 1px solid var(--border-color); border-radius: 3px;
  background: var(--bg-primary); cursor: pointer; position: relative; flex-shrink: 0;
}
.col-picker-item input[type="checkbox"]:checked {
  background: var(--blue); border-color: var(--blue);
}
.col-picker-item input[type="checkbox"]:checked::after {
  content: ''; position: absolute; top: 1px; left: 4px;
  width: 4px; height: 8px; border: solid #fff; border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

/* ── Column drag-and-drop ── */
thead th[draggable="true"] { cursor: grab; }
thead th[draggable="true"]:active { cursor: grabbing; }
thead th.col-dragging { opacity: 0.35; background: var(--bg-tertiary); }
thead th.col-drag-over-left { box-shadow: inset 3px 0 0 var(--blue); }
thead th.col-drag-over-right { box-shadow: inset -3px 0 0 var(--blue); }
.col-picker-item[draggable="true"] { cursor: grab; }
.col-picker-item[draggable="true"]:active { cursor: grabbing; }
.col-picker-item.picker-dragging { opacity: 0.35; background: var(--bg-tertiary); }
.col-picker-item.picker-drag-over { border-top: 2px solid var(--blue); }
.col-picker-item .drag-handle {
  display: flex; align-items: center; color: var(--text-muted);
  font-size: 11px; flex-shrink: 0; cursor: grab; padding: 0 2px;
  letter-spacing: 1px; line-height: 1; user-select: none;
}
.col-picker-item.disabled .drag-handle { visibility: hidden; }

/* ── Status Bar ── */
.status-bar {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 4px 16px; display: flex; align-items: center; gap: 16px;
  font-size: 11px; color: var(--text-muted); font-family: var(--font-mono);
  font-variant-numeric: tabular-nums;
}


.status-item { display: flex; align-items: center; gap: 5px; }
.status-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: var(--green); flex-shrink: 0;
}
.status-dot.loading {
  background: var(--yellow); animation: pulse-dot 1s ease-in-out infinite;
}
.status-dot.ws-live {
  background: var(--green); box-shadow: 0 0 6px rgba(34,197,94,0.5);
}
.status-dot.ws-disconnected { background: var(--red); }
.status-dot.ws-reconnecting {
  background: var(--yellow); animation: pulse-dot 1.5s ease-in-out infinite;
}
@keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
.status-separator { color: var(--border-color); }

/* ── Table Container ── */
.table-container {
  flex: 1; overflow: auto; position: relative; height: calc(100vh - 90px);
}

/* ── Table ── */
table {
  width: max-content; min-width: 100%; border-collapse: collapse;
  font-family: var(--font-mono); font-size: 12px;
  font-variant-numeric: tabular-nums lining-nums;
}
thead { position: sticky; top: 0; z-index: 10; }
thead th {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 6px 12px; text-align: right; font-weight: 600; font-size: 10px;
  text-transform: uppercase; letter-spacing: 0.6px; color: var(--text-muted);
  cursor: pointer; user-select: none; white-space: nowrap; position: relative;
  transition: color 0.15s;
}
thead th:hover { color: var(--text-secondary); }
thead th:first-child {
  text-align: left; position: sticky; left: 0; z-index: 11;
  background: var(--bg-secondary);
}
thead th .sort-arrow {
  display: inline-block; margin-left: 3px; font-size: 9px; opacity: 0.2;
}
thead th.sort-active { color: var(--text-secondary); }
thead th.sort-active .sort-arrow { opacity: 1; color: var(--blue); }
.sort-badge {
  display: inline-flex; align-items: center; justify-content: center;
  width: 14px; height: 14px; border-radius: 50%; background: var(--blue);
  color: #fff; font-size: 8px; font-weight: 700; margin-left: 3px;
  vertical-align: middle; font-family: var(--font-mono);
}

/* ── Table rows ── */
tbody tr {
  border-bottom: 1px solid var(--border-subtle);
  transition: background 0.1s; height: var(--row-height);
}
tbody tr:nth-child(even) { background: var(--bg-row-alt); }
tbody tr:hover { background: var(--bg-hover); }
tbody tr.updated td:first-child { box-shadow: inset 3px 0 0 var(--blue); }
tbody tr.updated { transition: none; }
tbody td {
  padding: 0 12px; text-align: right; white-space: nowrap;
  color: var(--text-primary); line-height: var(--row-height); font-size: 12px;
}
tbody td:first-child {
  text-align: left; font-weight: 600; position: sticky; left: 0; z-index: 5;
  background: var(--bg-primary); color: var(--blue); cursor: pointer;
}
tbody td:first-child:hover { text-decoration: underline; }
tbody tr:nth-child(even) td:first-child { background: var(--bg-row-alt); }
tbody tr:hover td:first-child { background: var(--bg-hover); }

/* ── Heatmap cells ── */
.cell-heat-green-1 { background: rgba(34,197,94,0.06); color: var(--green); }
.cell-heat-green-2 { background: rgba(34,197,94,0.10); color: var(--green-bright); }
.cell-heat-green-3 { background: rgba(34,197,94,0.16); color: var(--green-bright); font-weight: 600; }
.cell-heat-red-1   { background: rgba(239,68,68,0.06); color: var(--red); }
.cell-heat-red-2   { background: rgba(239,68,68,0.10); color: var(--red-bright); }
.cell-heat-red-3   { background: rgba(239,68,68,0.16); color: var(--red-bright); font-weight: 600; }

/* ── RSI ── */
.rsi-oversold { color: var(--green-bright); font-weight: 600; }
.rsi-low { color: var(--green); }
.rsi-neutral { color: var(--text-primary); }
.rsi-high { color: var(--orange); }
.rsi-overbought { color: var(--red-bright); font-weight: 600; }

/* ── Relative volume ── */
.rvol-high { color: var(--green-bright); font-weight: 600; }
.rvol-medium { color: var(--yellow); }
.rvol-normal { color: var(--text-primary); }

/* ── Change percent ── */
.change-positive { color: var(--green); }
.change-negative { color: var(--red); }

/* ── Condensed ── */
.tf-label { font-size: 9px; color: var(--text-muted); margin-left: 2px; }

/* ── Signal Column ── */
.signal-cell { text-align: center; }
.grade-badge {
  display: inline-block; padding: 2px 8px; border-radius: 4px;
  font-size: 11px; font-weight: 700; letter-spacing: 0.5px;
  font-family: var(--font-mono); line-height: 18px; white-space: nowrap;
}
.grade-A {
  background: rgba(255,193,7,0.25); color: #ffc107;
  border: 1px solid rgba(255,193,7,0.4); text-shadow: 0 0 6px rgba(255,193,7,0.2);
}
.grade-B {
  background: rgba(100,149,237,0.20); color: #6495ed;
  border: 1px solid rgba(100,149,237,0.3);
}
.grade-C {
  background: rgba(150,150,150,0.15); color: #999;
  border: 1px solid rgba(150,150,150,0.1);
}
.grade-D { background: rgba(80,80,80,0.10); color: #666; }
.grade-F { background: rgba(80,80,80,0.05); color: #555; }
.signal-dir {
  font-size: 10px; font-weight: 600; margin-left: 4px;
}
.signal-score {
  font-size: 10px; color: var(--text-muted); margin-top: 1px;
  font-family: var(--font-mono);
}
.catalyst-text {
  font-size: 9px; font-style: italic; color: var(--text-muted);
  margin-top: 1px; line-height: 1.2; max-width: 150px;
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}

/* ── Starred symbols ── */
.star-icon {
  cursor: pointer; opacity: 0.3; transition: opacity 0.2s;
  margin-right: 6px; font-size: 12px; display: inline;
}
.star-icon:hover { opacity: 0.7; }
.star-icon.starred { opacity: 1; color: #ffc107; }
.starred-divider td { border-bottom: 2px solid rgba(255,193,7,0.3) !important; }

/* ── Stacked (merged) cells ── */
.stacked-cell {
  display: flex; flex-direction: column; gap: 1px; line-height: 1.3;
}
.stacked-cell .secondary {
  font-size: 10px; color: var(--text-muted);
}

/* ── Row tinting for strong signals ── */
tr.signal-long-strong { background: rgba(0,200,100,0.03) !important; }
tr.signal-short-strong { background: rgba(255,60,60,0.03) !important; }

/* ── OI Delta ── */
.oi-new-long { color: var(--green-bright); font-weight: 600; }
.oi-new-short { color: var(--red-bright); font-weight: 600; }
.oi-short-cover { color: var(--yellow); }
.oi-liq-long { color: var(--orange); }
.oi-flat { color: var(--text-muted); }

/* ── 24h Range Position ── */
.range-at-high { color: var(--red-bright); font-weight: 600; }
.range-upper { color: var(--orange); }
.range-mid { color: var(--text-primary); }
.range-lower { color: var(--green); }
.range-at-low { color: var(--green-bright); font-weight: 600; }

/* ── CVD ── */
.cvd-bull { color: var(--green); }
.cvd-bear { color: var(--red); }
.cvd-neutral { color: var(--text-muted); }

/* ── Squeeze ── */
.squeeze-active {
  color: var(--yellow); font-weight: 700;
  background: rgba(234,179,8,0.10); padding: 1px 5px; border-radius: 3px;
}
.squeeze-building { color: var(--orange); }
.squeeze-none { color: var(--text-muted); }

/* ── Funding Velocity ── */
.fvel-rising { color: var(--red); }
.fvel-falling { color: var(--green); }
.fvel-flat { color: var(--text-muted); }

/* ── L/S Ratio ── */
.ls-long-heavy { color: var(--green); }
.ls-short-heavy { color: var(--red); }
.ls-neutral { color: var(--text-primary); }

/* ── Confluence filter pills (gold accent) ── */
.filter-pill.confluence {
  background: rgba(234,179,8,0.06); border-color: rgba(234,179,8,0.25);
  color: var(--yellow);
}
.filter-pill.confluence:hover {
  background: rgba(234,179,8,0.12); border-color: var(--yellow);
}
.filter-pill.confluence.active {
  background: rgba(234,179,8,0.18); border-color: var(--yellow); color: var(--yellow);
}


/* ── Loading overlay ── */
.loading-overlay {
  position: absolute; inset: 0; background: rgba(10,14,19,0.92);
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; gap: 12px; z-index: 50;
  font-family: var(--font-mono); color: var(--text-secondary); font-size: 13px;
}
.loading-overlay.hidden { display: none; }
.spinner {
  display: inline-block; width: 24px; height: 24px;
  border: 2px solid var(--border-color); border-top-color: var(--blue);
  border-radius: 50%; animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Empty state ── */
.empty-state {
  text-align: center; padding: 60px 20px; color: var(--text-muted); font-size: 13px;
}
.empty-state-hint {
  display: block; margin-top: 8px; font-size: 11px; color: var(--text-muted);
  opacity: 0.7;
}

/* ── Scrollbar ── */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
::-webkit-scrollbar-corner { background: var(--bg-primary); }

/* ── Responsive ── */
@media (max-width: 1400px) {
  :root { --row-height: 28px; }
  table { font-size: 11px; }
  thead th { padding: 5px 8px; font-size: 9px; }
  tbody td { padding: 0 8px; font-size: 11px; }
  .catalyst-text { display: none; }
}
@media (max-width: 1024px) {
  .header { padding: 8px 12px; gap: 8px; }
  .search-box { flex: 0 0 140px; }
  .filter-bar {
    overflow-x: auto; flex-wrap: nowrap; -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .filter-bar::-webkit-scrollbar { display: none; }
  .brand-sub { display: none; }
  .stacked-cell .secondary { font-size: 9px; }
}
@media (max-width: 768px) {
  :root { --row-height: 26px; }
  .header { flex-wrap: wrap; }
  .header-divider { display: none; }
  .search-box { flex: 1 1 100%; order: 10; }
  table { font-size: 10px; }
  thead th { padding: 4px 6px; font-size: 8px; letter-spacing: 0.3px; }
  tbody td { padding: 0 6px; font-size: 10px; }
  .filter-pill { padding: 3px 7px; font-size: 10px; }
  .status-bar { padding: 3px 10px; gap: 10px; font-size: 10px; }
  .signal-score { display: none; }
  .catalyst-text { display: none; }
  .tf-label { display: none; }
}
</style>
</head>
<body>

<div class="refresh-stripe" id="refreshStripe">
  <div class="stripe-bar" id="stripeBar"></div>
</div>

<div class="app-layout">
  <div class="header">
    <div class="brand">
      <svg class="brand-icon" viewBox="0 0 24 24" width="22" height="22" fill="none">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1.5" opacity="0.2"/>
        <circle cx="12" cy="12" r="6" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
        <circle cx="12" cy="12" r="2.5" fill="var(--blue)"/>
        <line x1="12" y1="12" x2="19" y2="5" stroke="var(--green)" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <div>
        <span class="brand-name"><span>Mello</span>Scan</span>
        <span class="brand-sub">Bybit Futures</span>
      </div>
    </div>
    <div class="header-divider"></div>
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="Search symbol..." spellcheck="false" />
    </div>
    <div class="header-divider"></div>
    <div class="filter-bar">
      <button class="filter-pill confluence" data-filter="grade-ab">A/B Grade</button>
      <button class="filter-pill" data-filter="ob-os">OB/OS</button>
      <button class="filter-pill" data-filter="squeeze">Squeeze</button>
      <div class="filter-dropdown" id="volFilterDropdown">
        <button class="filter-dropdown-btn" id="volFilterBtn">Vol <span id="volFilterLabel">All</span> <span class="dd-arrow">&#9662;</span></button>
        <div class="filter-dropdown-menu" id="volFilterMenu">
          <button data-vol="0" class="selected">All</button>
          <button data-vol="1000000">&gt; 1M</button>
          <button data-vol="5000000">&gt; 5M</button>
          <button data-vol="10000000">&gt; 10M</button>
          <button data-vol="25000000">&gt; 25M</button>
          <button data-vol="50000000">&gt; 50M</button>
          <button data-vol="100000000">&gt; 100M</button>
          <button data-vol="500000000">&gt; 500M</button>
        </div>
      </div>
      <div class="filter-dropdown" id="moreFilterDropdown">
        <button class="filter-dropdown-btn" id="moreFilterBtn">More <span class="dd-arrow">&#9662;</span></button>
        <div class="filter-dropdown-menu" id="moreFilterMenu">
          <button data-filter="divergence">Divergence</button>
          <button data-filter="choch-aligned">CHOCH Aligned</button>
          <button data-filter="oi-buildup">OI Buildup</button>
          <button data-filter="cvd-div">CVD Divergence</button>
          <button data-filter="rvol">RVol &gt; 2x</button>
        </div>
      </div>
      <button class="filter-clear" id="filterClear">Clear all</button>
      <span class="filter-result-count" id="filterResultCount"></span>
    </div>
    <div class="col-picker-wrapper">
      <button class="col-picker-btn" id="colPickerBtn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v18M3 12h18M5.5 5.5l13 13M18.5 5.5l-13 13"/></svg>
        Columns
      </button>
      <div class="col-picker-dropdown" id="colPickerDropdown">
        <div class="picker-header">Toggle &amp; reorder columns</div>
      </div>
    </div>
  </div>
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Initializing...</span>
    </div>
    <span class="status-separator">&middot;</span>
    <div class="status-item"><span id="instrumentCount">0</span> instruments</div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Updated <span id="lastRefresh">&mdash;</span></div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Indicators <span id="nextRefresh">&mdash;</span></div>
    <div class="status-item" id="dataProgress" style="display:none">
      <span class="status-separator">&middot;</span>
      <span id="dataProgressText"></span>
    </div>
  </div>

  <div class="table-container" id="tableContainer">
    <div class="loading-overlay" id="loadingOverlay">
      <div class="spinner"></div>
      Loading market data...
    </div>
    <table id="mainTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>


<script>
// ============================================================
// MelloScan — Bybit USDT Perpetual Screener
// ============================================================

const BYBIT_BASE = 'https://api.bybit.com';
const REFRESH_INTERVAL = 60000;
const BATCH_SIZE = 3;
const BATCH_DELAY = 250;
const RSI_PERIOD = 14;
const KLINE_LIMIT = 200;
const DAILY_KLINE_LIMIT = 50;
const DIV_LOOKBACK = 24;
const CACHE_KEY = 'melloscan_cache';
const CACHE_TS_KEY = 'melloscan_cache_ts';
const COL_PREFS_KEY = 'melloscan_columns';
const COL_ORDER_KEY = 'melloscan_col_order';
const BB_PERIOD = 20;
const BB_STD = 2;
const OI_HISTORY_LIMIT = 48;
const FUNDING_HISTORY_LIMIT = 10;

// ── WebSocket real-time feed ──
const WS_URL = 'wss://stream.bybit.com/v5/public/linear';
const WS_PING_INTERVAL = 20000;
const WS_RECONNECT_BASE_MS = 1000;
const WS_RECONNECT_MAX_MS = 30000;
const WS_SUB_BATCH = 10;
const KLINE_POLL_INTERVAL = 180000;   // 3 min — refresh RSI/divergence/CHOCH/CVD/squeeze
const OI_POLL_INTERVAL = 300000;      // 5 min — refresh OI delta, funding velocity, L/S ratio
const RENDER_THROTTLE_MS = 200;       // batch WS updates into renders

// ── Column definitions (7 merged columns default, extras in picker) ──
const DEFAULT_COLUMNS = [
  { key: 'symbol',        label: 'Symbol',       align: 'left',   locked: true },
  { key: 'priceChange',   label: 'Price',        align: 'right',  locked: false },
  { key: 'signal',        label: 'Signal',       align: 'center', locked: false },
  { key: 'rsiComposite',  label: 'RSI',          align: 'right',  locked: false },
  { key: 'oiFunding',     label: 'OI / Funding', align: 'right',  locked: false },
  { key: 'squeeze',       label: 'Squeeze',      align: 'right',  locked: false },
  { key: 'volume',        label: 'Volume',       align: 'right',  locked: false },
  // Hidden extras — available via column picker
  { key: 'openInterest',  label: 'OI',           align: 'right',  locked: false },
  { key: 'relVolume',     label: 'Rel Vol',      align: 'right',  locked: false },
];

const COLUMN_MAP = {};
DEFAULT_COLUMNS.forEach(c => { COLUMN_MAP[c.key] = c; });

// Default visible columns — clean 7-column view
const DEFAULT_VISIBLE_KEYS = new Set([
  'symbol', 'priceChange', 'signal', 'rsiComposite',
  'oiFunding', 'squeeze', 'volume'
]);

let columnOrder = DEFAULT_COLUMNS.map(c => c.key);
let visibleColumns = new Set(DEFAULT_VISIBLE_KEYS);

function getAllColumnsOrdered() {
  return columnOrder.map(k => COLUMN_MAP[k]).filter(Boolean);
}
function getVisibleColumns() {
  return columnOrder.filter(k => visibleColumns.has(k)).map(k => COLUMN_MAP[k]);
}

function loadColumnPrefs() {
  try {
    const saved = localStorage.getItem(COL_PREFS_KEY);
    if (saved) {
      const arr = JSON.parse(saved);
      if (Array.isArray(arr) && arr.length > 0) {
        visibleColumns = new Set(arr);
        visibleColumns.add('symbol');
      }
    }
  } catch (e) { /* ignore */ }
  try {
    const savedOrder = localStorage.getItem(COL_ORDER_KEY);
    if (savedOrder) {
      const arr = JSON.parse(savedOrder);
      if (Array.isArray(arr) && arr.length > 0) {
        const validKeys = new Set(DEFAULT_COLUMNS.map(c => c.key));
        const ordered = arr.filter(k => validKeys.has(k));
        DEFAULT_COLUMNS.forEach(c => {
          if (!ordered.includes(c.key)) ordered.push(c.key);
        });
        const symIdx = ordered.indexOf('symbol');
        if (symIdx > 0) { ordered.splice(symIdx, 1); ordered.unshift('symbol'); }
        columnOrder = ordered;
      }
    }
  } catch (e) { /* ignore */ }
}

function saveColumnPrefs() {
  try {
    localStorage.setItem(COL_PREFS_KEY, JSON.stringify([...visibleColumns]));
    localStorage.setItem(COL_ORDER_KEY, JSON.stringify(columnOrder));
  } catch (e) { /* ignore */ }
}

// ── State ──
let instruments = {};
let sortLevels = [{ key: 'volume', dir: -1 }];
let starredSymbols = new Set(JSON.parse(localStorage.getItem('mello_starred') || '[]'));

function toggleStar(symbol) {
  if (starredSymbols.has(symbol)) starredSymbols.delete(symbol);
  else starredSymbols.add(symbol);
  localStorage.setItem('mello_starred', JSON.stringify([...starredSymbols]));
  renderTable();
}
let activeFilters = new Set();
let volumeMinFilter = 0;
let searchText = '';
let refreshTimer = null;
let countdownTimer = null;
let nextRefreshAt = 0;
let isRefreshing = false;
let previousPrices = {};
let rsiAbortController = null;
let updateTimeouts = new Map(); // P3 fix: track row update timeouts

// WebSocket state
let wsConnection = null;
let wsReconnectAttempts = 0;
let wsPingTimer = null;
let wsConnected = false;
let wsFallbackTimer = null;
let dirtySymbols = new Set();
let renderThrottleTimer = null;
let klinePollTimer = null;
let oiPollTimer = null;

// ============================================================
// LocalStorage cache
// ============================================================

function saveCache() {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(instruments));
    localStorage.setItem(CACHE_TS_KEY, String(Date.now()));
  } catch (e) { console.warn('Cache save failed:', e.message); }
}

function loadCache() {
  try {
    const data = localStorage.getItem(CACHE_KEY);
    const ts = localStorage.getItem(CACHE_TS_KEY);
    if (!data || !ts) return false;
    const parsed = JSON.parse(data);
    if (!parsed || typeof parsed !== 'object' || Object.keys(parsed).length === 0) return false;
    instruments = parsed;
    const age = Date.now() - parseInt(ts, 10);
    const ageMin = Math.round(age / 60000);
    const ageStr = ageMin < 60 ? ageMin + 'm ago' : Math.round(ageMin / 60) + 'h ago';
    setStatus('Cached (' + ageStr + ')', true);
    updateInstrumentCount();
    renderTable();
    return true;
  } catch (e) {
    console.warn('Cache load failed:', e.message);
    return false;
  }
}

// ============================================================
// P0: Rate limiter + API with retry/backoff
// ============================================================

const rateLimiter = {
  timestamps: [],
  maxRequests: 80,  // Bybit limit: 120/5s — stay well under
  windowMs: 5000,
  async throttle() {
    const now = Date.now();
    this.timestamps = this.timestamps.filter(t => now - t < this.windowMs);
    if (this.timestamps.length >= this.maxRequests) {
      const oldest = this.timestamps[0];
      const waitMs = this.windowMs - (now - oldest) + 100;
      await new Promise(r => setTimeout(r, waitMs));
    }
    this.timestamps.push(Date.now());
  }
};

async function apiFetch(path, retries) {
  if (retries === undefined) retries = 3;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      await rateLimiter.throttle();
      const resp = await fetch(BYBIT_BASE + path);
      if (resp.status === 429) {
        const backoff = Math.pow(2, attempt) * 1000;
        console.warn('Rate limited on', path, '- backing off', backoff, 'ms');
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }
      if (!resp.ok) throw new Error('API ' + resp.status);
      const json = await resp.json();
      if (json.retCode !== 0) throw new Error('Bybit: ' + json.retMsg);
      return json.result;
    } catch (e) {
      if (attempt < retries && (e.name === 'TypeError' || e.message.includes('429'))) {
        const backoff = Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }
      throw e;
    }
  }
}

// ============================================================
// Data fetching
// ============================================================

async function fetchTickers() {
  const result = await apiFetch('/v5/market/tickers?category=linear');
  return (result.list || []).filter(t => t.symbol.endsWith('USDT'));
}


async function fetchKline(symbol, interval, limit) {
  const result = await apiFetch(
    '/v5/market/kline?category=linear&symbol=' + symbol +
    '&interval=' + interval + '&limit=' + limit
  );
  return (result.list || []).reverse();
}

async function fetchOIHistory(symbol) {
  const result = await apiFetch(
    '/v5/market/open-interest?category=linear&symbol=' + symbol +
    '&intervalTime=1h&limit=' + OI_HISTORY_LIMIT
  );
  return (result.list || []).reverse();
}

async function fetchFundingHistory(symbol) {
  const result = await apiFetch(
    '/v5/market/funding/history?category=linear&symbol=' + symbol +
    '&limit=' + FUNDING_HISTORY_LIMIT
  );
  return (result.list || []).reverse();
}

async function fetchAccountRatio(symbol) {
  const result = await apiFetch(
    '/v5/market/account-ratio?category=linear&symbol=' + symbol +
    '&period=1h&limit=1'
  );
  return result.list || [];
}

// ============================================================
// Technical calculations — existing
// ============================================================

function computeRSI(closes) {
  if (closes.length < RSI_PERIOD + 1) return null;
  var gains = 0, losses = 0;
  for (var i = 1; i <= RSI_PERIOD; i++) {
    var diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  var avgGain = gains / RSI_PERIOD;
  var avgLoss = losses / RSI_PERIOD;
  for (var i = RSI_PERIOD + 1; i < closes.length; i++) {
    var diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
  }
  if (avgLoss === 0) return 100;
  return 100 - 100 / (1 + avgGain / avgLoss);
}

function computeRSISeries(closes) {
  var rsiArr = new Array(closes.length).fill(null);
  if (closes.length < RSI_PERIOD + 1) return rsiArr;
  var gains = 0, losses = 0;
  for (var i = 1; i <= RSI_PERIOD; i++) {
    var diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  var avgGain = gains / RSI_PERIOD;
  var avgLoss = losses / RSI_PERIOD;
  rsiArr[RSI_PERIOD] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  for (var i = RSI_PERIOD + 1; i < closes.length; i++) {
    var diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
    rsiArr[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  }
  return rsiArr;
}

function detectDivergence(candles, rsiSeries) {
  var len = candles.length;
  if (len < 5) return 'none';
  var lookStart = Math.max(1, len - DIV_LOOKBACK);
  var lookEnd = len - 2;
  var swingLows = [], swingHighs = [];
  for (var i = lookStart; i <= lookEnd; i++) {
    if (rsiSeries[i] === null) continue;
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low, rsi: rsiSeries[i] });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high, rsi: rsiSeries[i] });
  }
  if (swingLows.length >= 2) {
    var recent = swingLows[swingLows.length - 1], prev = swingLows[swingLows.length - 2];
    if (recent.price < prev.price && recent.rsi > prev.rsi) return 'bull';
  }
  if (swingHighs.length >= 2) {
    var recent = swingHighs[swingHighs.length - 1], prev = swingHighs[swingHighs.length - 2];
    if (recent.price > prev.price && recent.rsi < prev.rsi) return 'bear';
  }
  return 'none';
}

function detectCHOCH(candles) {
  var len = candles.length;
  if (len < 10) return 'none';
  var swingHighs = [], swingLows = [];
  var lookStart = Math.max(1, len - 60);
  for (var i = lookStart; i < len - 1; i++) {
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high });
  }
  if (swingHighs.length < 2 || swingLows.length < 2) return 'none';
  var recentSH = swingHighs.slice(-3), recentSL = swingLows.slice(-3);
  var isDowntrend = false;
  for (var i = recentSH.length - 1; i >= 1; i--) {
    if (recentSH[i].price < recentSH[i - 1].price) { isDowntrend = true; break; }
  }
  if (isDowntrend) {
    var lastSH = recentSH[recentSH.length - 1];
    var rw = Math.min(5, len - lastSH.idx);
    for (var j = len - rw; j < len; j++) {
      if (candles[j].close > lastSH.price) return 'bull';
    }
  }
  var isUptrend = false;
  for (var i = recentSL.length - 1; i >= 1; i--) {
    if (recentSL[i].price > recentSL[i - 1].price) { isUptrend = true; break; }
  }
  if (isUptrend) {
    var lastSL = recentSL[recentSL.length - 1];
    var rw = Math.min(5, len - lastSL.idx);
    for (var j = len - rw; j < len; j++) {
      if (candles[j].close < lastSL.price) return 'bear';
    }
  }
  return 'none';
}

// ============================================================
// Technical calculations — 5 composite features
// ============================================================

// ── 1. OI Delta vs Price ──
function computeOIDelta(oiHistory) {
  if (!oiHistory || oiHistory.length < 2) return { pct24h: null, pct4h: null };
  var newest = parseFloat(oiHistory[oiHistory.length - 1].openInterest);
  var oldest = parseFloat(oiHistory[0].openInterest);
  if (oldest === 0 || isNaN(oldest) || isNaN(newest)) return { pct24h: null, pct4h: null };
  var pct24h = ((newest - oldest) / oldest) * 100;
  var idx4h = Math.max(0, oiHistory.length - 5);
  var oi4hAgo = parseFloat(oiHistory[idx4h].openInterest);
  var pct4h = oi4hAgo > 0 ? ((newest - oi4hAgo) / oi4hAgo) * 100 : null;
  return { pct24h: pct24h, pct4h: pct4h };
}

// P1: OI delta label with relative thresholds
function getOIDeltaLabel(oiPct, priceChg, change24h) {
  if (oiPct === null) return { label: '\u2014', cls: 'oi-flat', dir: 0 };
  // Relative threshold: OI change must be at least 30% of price change magnitude, min 0.5%
  var threshold = Math.max(0.5, Math.abs(change24h || 0) * 0.3);
  var oiUp = oiPct > threshold;
  var oiDown = oiPct < -threshold;
  var priceUp = priceChg > 0;
  if (oiUp && priceUp) return { label: 'NEW LONG', cls: 'oi-new-long', dir: 1 };
  if (oiUp && !priceUp) return { label: 'NEW SHRT', cls: 'oi-new-short', dir: -1 };
  if (oiDown && priceUp) return { label: 'SHT CVR', cls: 'oi-short-cover', dir: -0.5 };
  if (oiDown && !priceUp) return { label: 'LIQ LNG', cls: 'oi-liq-long', dir: 0.5 };
  return { label: 'FLAT', cls: 'oi-flat', dir: 0 };
}

// ── 2. P0: 24h Range Position (replaces Liquidation Proximity) ──
function computePricePosition(price, high24h, low24h) {
  if (!price || !high24h || !low24h || high24h <= low24h) {
    return { abovePct: null, belowPct: null, position: null };
  }
  var range = high24h - low24h;
  var abovePct = ((high24h - price) / price) * 100;
  var belowPct = ((price - low24h) / price) * 100;
  var position = (price - low24h) / range; // 0 = at 24h low, 1 = at 24h high
  return { abovePct: abovePct, belowPct: belowPct, position: position };
}

// ── 3. Volume Delta / CVD ──
function computeCVD(candles) {
  if (!candles || candles.length < 5) return { trend: 'neutral', divergence: 'none', value: 0 };
  var cvd = 0, cvdSeries = [], priceSeries = [];
  for (var ci = 0; ci < candles.length; ci++) {
    var c = candles[ci];
    var range = c.high - c.low;
    if (range === 0) { cvdSeries.push(cvd); priceSeries.push(c.close); continue; }
    var buyRatio = (c.close - c.low) / range;
    var vol = c.volume || 0;
    cvd += vol * (2 * buyRatio - 1);
    cvdSeries.push(cvd);
    priceSeries.push(c.close);
  }
  var lookback = Math.min(10, cvdSeries.length);
  var recentCVD = cvdSeries.slice(-lookback);
  var cvdChange = recentCVD[recentCVD.length - 1] - recentCVD[0];
  var trend = cvdChange > 0 ? 'bull' : cvdChange < 0 ? 'bear' : 'neutral';
  var divergence = 'none';
  if (priceSeries.length >= 10) {
    var recentPrice = priceSeries.slice(-lookback);
    var priceChange = recentPrice[recentPrice.length - 1] - recentPrice[0];
    if (priceChange < 0 && cvdChange > 0) divergence = 'bull';
    else if (priceChange > 0 && cvdChange < 0) divergence = 'bear';
  }
  return { trend: trend, divergence: divergence, value: cvd };
}

// ── 4. Volatility Squeeze + OI (FIX: indexOf bias) ──
function computeSqueeze(closes) {
  if (!closes || closes.length < BB_PERIOD + 20) return { active: false, building: false, pctile: null };
  var widths = [];
  for (var i = BB_PERIOD; i <= closes.length; i++) {
    var slice = closes.slice(i - BB_PERIOD, i);
    var sma = slice.reduce(function(a, b) { return a + b; }, 0) / BB_PERIOD;
    if (sma === 0) { widths.push(0); continue; }
    var variance = slice.reduce(function(sum, val) { return sum + (val - sma) * (val - sma); }, 0) / BB_PERIOD;
    widths.push((2 * BB_STD * Math.sqrt(variance)) / sma);
  }
  if (widths.length < 2) return { active: false, building: false, pctile: null };
  var currentWidth = widths[widths.length - 1];
  var lookback = Math.min(20, widths.length);
  var recentWidths = widths.slice(-lookback);
  // FIX: Use count-based percentile instead of indexOf (avoids duplicate bias)
  var belowCount = recentWidths.filter(function(w) { return w < currentWidth; }).length;
  var pctile = belowCount / (recentWidths.length - 1);
  return { active: pctile <= 0.25, building: pctile > 0.25 && pctile <= 0.40, pctile: pctile };
}

// ── 5. Funding Velocity ──
function computeFundingVelocity(fundingHistory) {
  if (!fundingHistory || fundingHistory.length < 3) return { slope: null, dir: 'flat', current: null, avg: null };
  var rates = fundingHistory.map(function(f) { return parseFloat(f.fundingRate); }).filter(function(r) { return !isNaN(r); });
  if (rates.length < 3) return { slope: null, dir: 'flat', current: null, avg: null };
  var n = rates.length, sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (var i = 0; i < n; i++) {
    sumX += i; sumY += rates[i]; sumXY += i * rates[i]; sumX2 += i * i;
  }
  var denom = n * sumX2 - sumX * sumX;
  var slope = denom !== 0 ? (n * sumXY - sumX * sumY) / denom : 0;
  var avg = sumY / n;
  var threshold = 0.00002;
  var dir = slope > threshold ? 'rising' : slope < -threshold ? 'falling' : 'flat';
  return { slope: slope, dir: dir, current: rates[rates.length - 1], avg: avg };
}

// ============================================================
// Number formatting
// ============================================================

function formatPrice(p) {
  var n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  if (n >= 1000) return n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  if (n >= 1) return n.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
  var s = n.toFixed(8), parts = s.split('.'), dec = parts[1];
  while (dec.length > 4 && dec.endsWith('0')) dec = dec.slice(0, -1);
  return parts[0] + '.' + dec;
}

function formatVolume(v) {
  var n = parseFloat(v);
  if (isNaN(n)) return '\u2014';
  if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toFixed(0);
}

function formatPct(p) {
  var n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + n.toFixed(2) + '%';
}

function formatFundingRate(r) {
  var n = parseFloat(r);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + (n * 100).toFixed(4) + '%';
}

// ============================================================
// Cell class helpers
// ============================================================

function rsiClass(v) {
  if (v === null || v === undefined) return 'rsi-neutral';
  if (v <= 30) return 'rsi-oversold';
  if (v <= 40) return 'rsi-low';
  if (v <= 60) return 'rsi-neutral';
  if (v <= 70) return 'rsi-high';
  return 'rsi-overbought';
}

function rvolClass(v) {
  if (v === null || v === undefined) return 'rvol-normal';
  if (v > 1.5) return 'rvol-high';
  if (v >= 1.2) return 'rvol-medium';
  return 'rvol-normal';
}

function changeHeatClass(v) {
  var n = parseFloat(v);
  if (isNaN(n)) return '';
  var abs = Math.abs(n);
  if (n > 0) {
    if (abs >= 8) return 'cell-heat-green-3';
    if (abs >= 3) return 'cell-heat-green-2';
    if (abs >= 1) return 'cell-heat-green-1';
  } else if (n < 0) {
    if (abs >= 8) return 'cell-heat-red-3';
    if (abs >= 3) return 'cell-heat-red-2';
    if (abs >= 1) return 'cell-heat-red-1';
  }
  return '';
}

function rangePositionClass(position) {
  if (position === null || position === undefined) return 'range-mid';
  if (position >= 0.9) return 'range-at-high';
  if (position >= 0.7) return 'range-upper';
  if (position <= 0.1) return 'range-at-low';
  if (position <= 0.3) return 'range-lower';
  return 'range-mid';
}

// ============================================================
// Condensed column helpers
// ============================================================

function getMostExtremeRSI_HTF(d) {
  var rsis = [
    { val: d.rsi4h, tf: '4H' },
    { val: d.rsiDaily, tf: 'D' },
  ].filter(function(r) { return r.val !== null && r.val !== undefined; });
  if (rsis.length === 0) return { val: null, tf: '' };
  rsis.sort(function(a, b) { return Math.abs(b.val - 50) - Math.abs(a.val - 50); });
  return rsis[0];
}

function getChochSummary(d) {
  var chochs = [
    { val: d.choch15m, tf: '15m' }, { val: d.choch30m, tf: '30m' },
    { val: d.choch4h, tf: '4H' }, { val: d.chochDaily, tf: 'D' },
  ];
  var active = chochs.filter(function(c) { return c.val !== 'none' && c.val !== undefined; });
  if (active.length === 0) return { dir: 'none', count: 0, aligned: false };
  var bulls = active.filter(function(c) { return c.val === 'bull'; }).length;
  var bears = active.filter(function(c) { return c.val === 'bear'; }).length;
  var dir = bulls > bears ? 'bull' : bears > bulls ? 'bear' : 'mixed';
  var aligned = active.length >= 2 && active.every(function(c) { return c.val === active[0].val; });
  return { dir: dir, count: active.length, aligned: aligned };
}

// ============================================================
// Composite signal scoring — FIXED weighted system
// ============================================================
// P0: Range Position at 5% (was Liq Prox at 20%)
// P1: Squeeze multiplier moved to END
// P1: OI Delta uses relative thresholds
// P2: L/S Ratio added at 5%
// Weights: OI 25%, CVD 20%, Squeeze 15% (mult), FundVel 10%,
//          RSI+Div 15%, Range 5%, L/S 5%, CHOCH 5%
// ============================================================

// ============================================================
// CONFLUENCE ENGINE — Unified Scoring System
// ============================================================
// Replaces computeSignal + computeSetupGrade + computeEdgeScore
// with a single coherent pipeline based on 4 independent pillars.
//
// Architecture:
//   Step 1: Score each pillar independently (-1.0 to +1.0)
//   Step 2: Weighted composite = Σ(pillar × weight)
//   Step 3: Confluence gate = how many pillars agree
//   Step 4: Conviction multipliers (TF alignment, squeeze, volume)
//   Step 5: Output unified result
//
// Methodology sources:
//   - Elder Triple Screen (HTF dominance)
//   - Grinold's Fundamental Law (independent signal sources)
//   - Minervini SEPA (minimum criteria gate)
//   - Bayesian confluence (pillar agreement = higher posterior)
// ============================================================

// Helper: clamp value to range
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }

// Helper: linear map from one range to another
function mapRange(v, inLo, inHi, outLo, outHi) {
  return outLo + (v - inLo) / (inHi - inLo) * (outHi - outLo);
}

// ── PILLAR 1: TREND (30% weight) ──
// Answers: "Which direction is market structure pointing?"
function scoreTrendPillar(d) {
  var score = 0;
  var weights = 0;

  // 1a. CHOCH Multi-Timeframe (50% of pillar)
  // Weighted: 4h 0.45 (dominant), Daily 0.25, 30m 0.18, 15m 0.12
  var chochEntries = [
    { val: d.choch4h,    w: 0.45 },
    { val: d.chochDaily, w: 0.25 },
    { val: d.choch30m,   w: 0.18 },
    { val: d.choch15m,   w: 0.12 },
  ];
  var chochScore = 0;
  var chochW = 0;
  for (var i = 0; i < chochEntries.length; i++) {
    var c = chochEntries[i];
    if (c.val === 'bull') { chochScore += c.w; chochW += c.w; }
    else if (c.val === 'bear') { chochScore -= c.w; chochW += c.w; }
    else if (c.val === 'none') { chochW += c.w * 0.3; } // Neutral — slight dilution
  }
  var chochNorm = chochW > 0 ? clamp(chochScore / chochW, -1, 1) : 0;

  // HTF dominance enforcement: 4h CHOCH is the tide — caps opposing LTF signals
  if (d.choch4h === 'bear' && chochNorm > 0.3) chochNorm = 0.3;
  if (d.choch4h === 'bull' && chochNorm < -0.3) chochNorm = -0.3;

  score += chochNorm * 0.50;
  weights += 0.50;

  // 1b. RSI Trend Composite (30% of pillar)
  // RSI > 50 = bullish momentum, < 50 = bearish
  var rsiTrend = [
    { val: d.rsiDaily, w: 0.40 },
    { val: d.rsi4h,    w: 0.35 },
    { val: d.rsi30m,   w: 0.15 },
    { val: d.rsi15m,   w: 0.10 },
  ];
  var rsiTrendScore = 0;
  var rsiTrendW = 0;
  for (var ri = 0; ri < rsiTrend.length; ri++) {
    var r = rsiTrend[ri];
    if (r.val === null || r.val === undefined) continue;
    rsiTrendW += r.w;
    // Map RSI to -1..+1: 50 = 0, 70+ = +1, 30- = -1
    var rNorm;
    if (r.val >= 50) rNorm = clamp(mapRange(r.val, 50, 70, 0, 1), 0, 1);
    else rNorm = clamp(mapRange(r.val, 30, 50, -1, 0), -1, 0);
    rsiTrendScore += rNorm * r.w;
  }
  var rsiTrendNorm = rsiTrendW > 0 ? clamp(rsiTrendScore / rsiTrendW, -1, 1) : 0;
  score += rsiTrendNorm * 0.30;
  weights += 0.30;

  // 1c. 24h Price Change (20% of pillar)
  if (d.change24h !== null && d.change24h !== undefined) {
    var priceScore = clamp(d.change24h / 10, -1, 1); // ±10% = full score
    score += priceScore * 0.20;
  }
  weights += 0.20;

  return weights > 0 ? clamp(score / weights, -1, 1) : 0;
}

// ── PILLAR 2: MOMENTUM (25% weight) ──
// Answers: "Is the move accelerating, exhausted, or coiled?"
function scoreMomentumPillar(d, directionHint) {
  var score = 0;
  var weights = 0;

  // 2a. RSI Divergences (40% of pillar)
  var divScore = 0;
  var hasBullDiv = d.div15m === 'bull' || d.div30m === 'bull';
  var hasBearDiv = d.div15m === 'bear' || d.div30m === 'bear';
  var bothBull = d.div15m === 'bull' && d.div30m === 'bull';
  var bothBear = d.div15m === 'bear' && d.div30m === 'bear';
  if (hasBullDiv) divScore += bothBull ? 1.0 : 0.7;
  if (hasBearDiv) divScore -= bothBear ? 1.0 : 0.7;
  divScore = clamp(divScore, -1, 1);
  score += divScore * 0.40;
  weights += 0.40;

  // 2b. BB Squeeze (35% of pillar) — non-directional catalyst
  // Squeeze magnitude is always positive; direction comes from other pillars
  var sqzMag = 0;
  if (d.squeezeOn) sqzMag = 1.0;
  else if (d.squeezeBuilding) sqzMag = 0.6;
  else if (d.squeezePctile !== null && d.squeezePctile !== undefined) {
    if (d.squeezePctile < 0.20) sqzMag = 0.4; // Tightening
    else if (d.squeezePctile > 0.80) sqzMag = -0.3; // Over-expanded = exhaustion
    else sqzMag = 0;
  }
  // Direction comes from the hint (other pillars' lean)
  var sqzDir = directionHint >= 0 ? 1 : -1;
  score += (sqzMag > 0 ? sqzMag * sqzDir : sqzMag * sqzDir) * 0.35;
  weights += 0.35;

  // 2c. Range Position (25% of pillar) — context-dependent
  if (d.rangePosition !== null && d.rangePosition !== undefined) {
    var rpScore = 0;
    var rp = d.rangePosition;
    // Use trend direction from hint for context
    if (directionHint > 0.1) {
      // In uptrend context: near lows = buy dip (+0.7), near highs = continuation (+0.3)
      if (rp < 0.20) rpScore = 0.7;
      else if (rp < 0.40) rpScore = 0.5;
      else if (rp > 0.90) rpScore = -0.3; // Extended — caution
      else rpScore = 0.3;
    } else if (directionHint < -0.1) {
      // In downtrend context: near highs = sell rip (-0.7), near lows = extended (-0.3)
      if (rp > 0.80) rpScore = -0.7;
      else if (rp > 0.60) rpScore = -0.5;
      else if (rp < 0.10) rpScore = 0.3; // Oversold bounce
      else rpScore = -0.3;
    } else {
      // Neutral/ranging: mean-reversion
      rpScore = clamp((0.5 - rp) * 2, -0.5, 0.5);
    }
    score += rpScore * 0.25;
  }
  weights += 0.25;

  return weights > 0 ? clamp(score / weights, -1, 1) : 0;
}

// ── PILLAR 3: FLOW (25% weight) ──
// Answers: "Is real money backing this move?"
function scoreFlowPillar(d) {
  var score = 0;
  var weights = 0;

  // 3a. CVD Trend + Divergence (40% of pillar)
  var cvdScore = 0;
  if (d.cvdTrend === 'bull') cvdScore += 0.5;
  else if (d.cvdTrend === 'bear') cvdScore -= 0.5;
  if (d.cvdDivergence === 'bull') cvdScore += 0.5;
  else if (d.cvdDivergence === 'bear') cvdScore -= 0.5;
  cvdScore = clamp(cvdScore, -1, 1);
  score += cvdScore * 0.40;
  weights += 0.40;

  // 3b. OI Delta (35% of pillar) — context matrix
  if (d.oiDeltaPct !== null && d.oiDeltaPct !== undefined) {
    var oiScore = 0;
    var priceUp = (d.change24h || 0) > 0;
    var oiUp = d.oiDeltaPct > 0;
    var oiMag = clamp(Math.abs(d.oiDeltaPct) / 5, 0, 1); // 5% OI change = full magnitude

    if (oiUp && priceUp) oiScore = 0.8 * oiMag;       // New longs entering
    else if (oiUp && !priceUp) oiScore = -0.8 * oiMag; // New shorts entering
    else if (!oiUp && priceUp) oiScore = 0.3 * oiMag;  // Short covering (weak rally)
    else oiScore = 0.5 * oiMag;                          // Capitulation (contrarian bullish)

    // Blend short-term and 4h delta (60/40 in favor of 4h)
    if (d.oiDelta4h !== null && d.oiDelta4h !== undefined) {
      var oi4hScore = 0;
      var oi4hUp = d.oiDelta4h > 0;
      var oi4hMag = clamp(Math.abs(d.oiDelta4h) / 8, 0, 1);
      if (oi4hUp && priceUp) oi4hScore = 0.8 * oi4hMag;
      else if (oi4hUp && !priceUp) oi4hScore = -0.8 * oi4hMag;
      else if (!oi4hUp && priceUp) oi4hScore = 0.3 * oi4hMag;
      else oi4hScore = 0.5 * oi4hMag;
      oiScore = oiScore * 0.40 + oi4hScore * 0.60;
    }
    score += clamp(oiScore, -1, 1) * 0.35;
  }
  weights += 0.35;

  // 3c. Relative Volume (25% of pillar) — participation confirmation
  var rvolScore = 0;
  if (d.relVolume !== null && d.relVolume !== undefined) {
    if (d.relVolume >= 3.0) rvolScore = 1.0;       // Strong volume (includes 5x+)
    else if (d.relVolume >= 2.0) rvolScore = 0.8;
    else if (d.relVolume >= 1.2) rvolScore = 0.3;
    else if (d.relVolume >= 0.8) rvolScore = 0;     // Neutral — normal volume
    else rvolScore = -0.4;                            // Low participation
  }
  // RVOL is non-directional; it acts as conviction, not direction
  // We keep it as-is (positive = good) rather than multiplying by direction
  score += rvolScore * 0.25;
  weights += 0.25;

  return weights > 0 ? clamp(score / weights, -1, 1) : 0;
}

// ── PILLAR 4: SENTIMENT (20% weight) ──
// Answers: "How is the crowd positioned, and are they wrong?"
function scoreSentimentPillar(d) {
  var score = 0;
  var weights = 0;

  // 4a. Funding Rate (40% of pillar) — contrarian at extremes
  var fr = d.fundingRate;
  if (fr !== null && fr !== undefined && !isNaN(fr)) {
    var frPct = fr * 100; // Convert to percentage
    var frScore = 0;
    if (frPct > 0.05) frScore = -1.0;         // Extreme bullish crowding → bearish
    else if (frPct > 0.03) frScore = -0.5;     // Elevated bullish → mild bearish
    else if (frPct > 0.01) frScore = 0.2;      // Moderate → slight trend confirm
    else if (frPct > -0.01) frScore = 0;        // Neutral
    else if (frPct > -0.03) frScore = -0.2;    // Moderate bearish → slight trend confirm
    else if (frPct > -0.05) frScore = 0.5;     // Elevated bearish crowding → mild bullish
    else frScore = 1.0;                         // Extreme bearish crowding → bullish
    score += frScore * 0.40;
  }
  weights += 0.40;

  // 4b. Funding Velocity (30% of pillar) — acceleration of positioning
  if (d.fundVelDir && d.fundVelSlope !== null) {
    var fvScore = 0;
    if (d.fundVelDir === 'rising') {
      // Funding accelerating positive → overheating → bearish lean
      fvScore = -clamp(Math.abs(d.fundVelSlope) / 0.0002, 0, 1);
    } else if (d.fundVelDir === 'falling') {
      // Funding collapsing → unwind → bullish lean
      fvScore = clamp(Math.abs(d.fundVelSlope) / 0.0002, 0, 1);
    }
    score += fvScore * 0.30;
  }
  weights += 0.30;

  // 4c. Long/Short Ratio (30% of pillar) — contrarian at extremes
  if (d.lsRatio !== null && d.lsRatio !== undefined) {
    var lsScore = 0;
    var ls = d.lsRatio; // buyRatio 0..1
    if (ls > 0.65) lsScore = -1.0;          // Extreme long crowding
    else if (ls > 0.55) lsScore = -0.5;     // Elevated long
    else if (ls > 0.45) lsScore = 0;         // Neutral zone
    else if (ls > 0.35) lsScore = 0.5;      // Elevated short
    else lsScore = 1.0;                      // Extreme short crowding
    score += lsScore * 0.30;
  }
  weights += 0.30;

  return weights > 0 ? clamp(score / weights, -1, 1) : 0;
}

// ── MASTER CONFLUENCE FUNCTION ──
function computeConfluence(d) {
  // Step 1: Score each pillar independently
  var trend = scoreTrendPillar(d);
  var flow = scoreFlowPillar(d);
  var sentiment = scoreSentimentPillar(d);
  // Momentum needs a direction hint from the other pillars (for squeeze & range context)
  var directionHint = trend * 0.50 + flow * 0.30 + sentiment * 0.20;
  var momentum = scoreMomentumPillar(d, directionHint);

  // Step 2: Weighted composite (Flow/Sentiment weighted higher — futures edge)
  var composite = (0.25 * trend) + (0.20 * momentum) + (0.30 * flow) + (0.25 * sentiment);
  composite = clamp(composite, -1, 1);

  // Step 3: Confluence gate — how many pillars agree with composite direction
  var compSign = composite >= 0 ? 1 : -1;
  var pillarSigns = [
    trend >= 0.05 ? 1 : trend <= -0.05 ? -1 : 0,
    momentum >= 0.05 ? 1 : momentum <= -0.05 ? -1 : 0,
    flow >= 0.05 ? 1 : flow <= -0.05 ? -1 : 0,
    sentiment >= 0.05 ? 1 : sentiment <= -0.05 ? -1 : 0,
  ];
  var pillarsAgreeing = 0;
  var pillarsActive = 0;
  for (var pi = 0; pi < pillarSigns.length; pi++) {
    if (pillarSigns[pi] !== 0) pillarsActive++;
    if (pillarSigns[pi] === compSign) pillarsAgreeing++;
  }

  var gate;
  if (pillarsAgreeing >= 4) gate = 1.00;
  else if (pillarsAgreeing === 3) gate = 0.80;
  else if (pillarsAgreeing === 2) gate = 0.55;
  else if (pillarsAgreeing === 1) gate = 0.25;
  else gate = 0;

  var gated = composite * gate;

  // Step 4: Conviction multipliers
  // TF Alignment: 4h + 30m CHOCH agreement (4h is the dominant HTF)
  var tfMult = 1.0;
  if (d.choch4h !== 'none' && d.choch30m !== 'none') {
    if (d.choch4h === d.choch30m) tfMult = 1.15; // Aligned — boost
    else tfMult = 0.70; // Conflicting — dampen
  }
  // Squeeze catalyst: only amplify if there's already a signal
  var sqzMult = 1.0;
  if (d.squeezeOn && Math.abs(gated) > 0.15) sqzMult = 1.20;
  else if (d.squeezeBuilding && Math.abs(gated) > 0.15) sqzMult = 1.10;
  // Volume confirmation
  var volMult = 1.0;
  if (d.relVolume !== null && d.relVolume >= 2.0) volMult = 1.10;
  else if (d.relVolume !== null && d.relVolume < 0.8) volMult = 0.75;

  var final = clamp(gated * tfMult * sqzMult * volMult, -1, 1);

  // Step 5: Derive outputs
  var absScore = Math.abs(final);
  var direction, grade, cls;
  if (final > 0.24) direction = 'LONG';
  else if (final < -0.24) direction = 'SHORT';
  else direction = 'NEUTRAL';

  if (absScore >= 0.65) { grade = 'A'; cls = 'grade-A'; }
  else if (absScore >= 0.40) { grade = 'B'; cls = 'grade-B'; }
  else if (absScore >= 0.20) { grade = 'C'; cls = 'grade-C'; }
  else if (absScore >= 0.08) { grade = 'D'; cls = 'grade-D'; }
  else { grade = 'F'; cls = 'grade-F'; }

  // Edge tags — quick visual flags
  var tags = [];
  if (d.squeezeOn) tags.push('SQ');
  else if (d.squeezeBuilding) tags.push('SQ');
  var isLong = final >= 0;
  if (d.oiDeltaPct !== null && Math.abs(d.oiDeltaPct) > 2) {
    var oiDir = (d.change24h > 0 && d.oiDeltaPct > 0) || (d.change24h < 0 && d.oiDeltaPct > 0);
    tags.push('OI');
  }
  if ((isLong && (d.cvdTrend === 'bull' || d.cvdDivergence === 'bull')) ||
      (!isLong && (d.cvdTrend === 'bear' || d.cvdDivergence === 'bear'))) tags.push('CVD');
  if ((isLong && (d.div15m === 'bull' || d.div30m === 'bull')) ||
      (!isLong && (d.div15m === 'bear' || d.div30m === 'bear'))) tags.push('DIV');
  if (d.relVolume !== null && d.relVolume >= 2.0) tags.push('RV');
  if ((isLong && d.fundVelDir === 'falling') || (!isLong && d.fundVelDir === 'rising')) tags.push('FV');
  var ch = getChochSummary(d);
  if (ch.aligned && ch.count >= 3) tags.push('MTF');
  if (d.oiDeltaPct !== null && d.oiDeltaPct < -3 && (d.change24h || 0) < -2) tags.push('CAP');

  // Sizing recommendation (0-100%)
  var sizing = 0;
  if (absScore >= 0.70 && pillarsAgreeing >= 4) sizing = 90;
  else if (absScore >= 0.70 && pillarsAgreeing >= 3) sizing = 75;
  else if (absScore >= 0.45 && pillarsAgreeing >= 3) sizing = 60;
  else if (absScore >= 0.45 && pillarsAgreeing >= 2) sizing = 40;
  else if (absScore >= 0.25 && pillarsAgreeing >= 3) sizing = 40;
  else if (absScore >= 0.25 && pillarsAgreeing >= 2) sizing = 25;
  else sizing = 0;

  // Score as 0-100 for grade display compatibility
  var score100 = Math.round(absScore * 100);

  return {
    direction: direction,
    composite: Math.round(composite * 1000) / 1000,
    final: Math.round(final * 1000) / 1000,
    confidence: score100,
    grade: grade,
    cls: cls,
    gate: pillarsAgreeing,
    pillars: {
      trend:     Math.round(trend * 100) / 100,
      momentum:  Math.round(momentum * 100) / 100,
      flow:      Math.round(flow * 100) / 100,
      sentiment: Math.round(sentiment * 100) / 100,
    },
    tags: tags,
    sizing: sizing,
    catalyst: '',  // Filled in by determineCatalyst() after attachment to instrument
    // Backward-compatible fields
    score: score100,
    dir: direction === 'NEUTRAL' ? (final >= 0 ? 'LONG' : 'SHORT') : direction,
  };
}

// ── Catalyst determination — human-readable driver of the signal ──
function determineCatalyst(d) {
  var catalysts = [];

  // Squeeze catalyst (highest priority visual catalyst)
  if (d.squeezeOn) catalysts.push('Squeeze firing');
  else if (d.squeezeBuilding) catalysts.push('Squeeze building');

  // OI-driven catalyst
  if (d.oiDeltaPct !== null && d.oiDeltaPct !== undefined) {
    var oiAbs = Math.abs(d.oiDeltaPct);
    if (oiAbs > 5) {
      var oiLbl = getOIDeltaLabel(d.oiDeltaPct, d.change24h, d.change24h);
      if (oiLbl.label !== 'FLAT') catalysts.push(oiLbl.label);
    }
  }

  // Funding extreme (contrarian signal)
  var fr = Math.abs(d.fundingRate || 0);
  if (fr > 0.0003) {
    var frDir = d.fundingRate > 0 ? 'longs paying' : 'shorts paying';
    catalysts.push('Funding extreme (' + frDir + ')');
  }

  // Divergence catalyst
  var hasDiv = (d.div15m && d.div15m !== 'none') || (d.div30m && d.div30m !== 'none');
  if (hasDiv) {
    var divType = d.div15m !== 'none' ? d.div15m : d.div30m;
    catalysts.push(divType.charAt(0).toUpperCase() + divType.slice(1) + ' divergence');
  }

  // CVD divergence
  if (d.cvdDivergence && d.cvdDivergence !== 'none') {
    catalysts.push('CVD divergence');
  }

  // Extreme RVOL
  if ((d.relVolume || 0) >= 5) {
    catalysts.push('Extreme volume (' + d.relVolume.toFixed(1) + 'x)');
  }

  // Multi-timeframe CHOCH alignment
  var ch = getChochSummary(d);
  if (ch.aligned && ch.count >= 3) {
    catalysts.push('MTF structure aligned');
  }

  // Return top 2 catalysts max
  if (catalysts.length === 0) return 'No clear catalyst';
  return catalysts.slice(0, 2).join(' + ');
}

// Backward-compatible wrappers (used by existing code)
function computeSignal(d) {
  var c = computeConfluence(d);
  // Map -1..+1 final score to roughly -20..+20 range for old consumers
  return Math.round(c.final * 20 * 10) / 10;
}

function computeSetupGrade(d) {
  var c = d._confluence || computeConfluence(d);
  return {
    grade: c.grade,
    score: c.score,
    cls: c.cls,
    dir: c.dir,
    pillars: {
      trend:   Math.round(Math.abs(c.pillars.trend) * 25),
      momentum: Math.round(Math.abs(c.pillars.momentum) * 20),
      flow: Math.round(Math.abs(c.pillars.flow) * 30),
      sentiment:  Math.round(Math.abs(c.pillars.sentiment) * 25),
    }
  };
}

function computeEdgeScore(d) {
  var c = d._confluence || computeConfluence(d);
  return { score: Math.min(Math.round(c.gate * 2 + c.tags.length), 10), tags: c.tags };
}

// Update signal for a symbol (cached, only called on data change)
function updateSignalFor(symbol) {
  var d = instruments[symbol];
  if (d) {
    d._confluence = computeConfluence(d);
    d._confluence.catalyst = determineCatalyst(d);
    d._signal = computeSignal(d);
    d._grade = computeSetupGrade(d);
    d._edge = computeEdgeScore(d);
  }
}

// ============================================================
// DOM cell builders (XSS hardening — no innerHTML for data)
// ============================================================

// ── Symbol cell with star + TradingView link ──
function buildSymbolCell(td, d) {
  var star = document.createElement('span');
  star.className = 'star-icon' + (starredSymbols.has(d.symbol) ? ' starred' : '');
  star.textContent = starredSymbols.has(d.symbol) ? '\u2605' : '\u2606';
  star.addEventListener('click', function(e) {
    e.stopPropagation();
    toggleStar(d.symbol);
  });
  td.appendChild(star);
  var link = document.createElement('span');
  link.textContent = d.symbol;
  td.appendChild(link);
}

// ── Price + Change merged cell ──
function buildPriceChangeCell(td, d) {
  td.className = 'stacked-cell';
  var priceRow = document.createElement('div');
  priceRow.textContent = formatPrice(d.price);
  td.appendChild(priceRow);
  var chgRow = document.createElement('div');
  chgRow.className = 'secondary';
  chgRow.textContent = formatPct(d.change24h);
  chgRow.style.color = d.change24h >= 0 ? 'var(--green)' : 'var(--red)';
  td.appendChild(chgRow);
}

// ── Signal (hero column) ──
function buildSignalCell(td, d) {
  td.className = 'signal-cell';
  var c = d._confluence;
  var g = d._grade;
  if (!c || !g) { td.textContent = '\u2014'; return; }

  // Grade badge + direction
  var badge = document.createElement('span');
  badge.className = 'grade-badge ' + c.cls;
  badge.textContent = c.grade;
  td.appendChild(badge);

  var dir = document.createElement('span');
  dir.className = 'signal-dir';
  dir.textContent = ' ' + c.dir;
  dir.style.color = c.dir === 'LONG' ? 'var(--green)' : c.dir === 'SHORT' ? 'var(--red)' : 'var(--text-muted)';
  td.appendChild(dir);

  // Score percentage
  var scoreLine = document.createElement('div');
  scoreLine.className = 'signal-score';
  scoreLine.textContent = c.score + '%';
  td.appendChild(scoreLine);

  // Catalyst text
  if (c.catalyst && c.catalyst !== 'No clear catalyst') {
    var catLine = document.createElement('div');
    catLine.className = 'catalyst-text';
    catLine.textContent = c.catalyst;
    td.appendChild(catLine);
  }

  // Tooltip
  td.title = 'T:' + c.pillars.trend + ' M:' + c.pillars.momentum +
    ' F:' + c.pillars.flow + ' S:' + c.pillars.sentiment +
    ' | Gate: ' + c.gate + '/4' +
    (c.tags.length > 0 ? ' | ' + c.tags.join(', ') : '');
}

// ── RSI Composite — most extreme across all TFs ──
function getMostExtremeRSI(d) {
  var rsis = [
    { val: d.rsi15m, tf: '15m', div: d.div15m },
    { val: d.rsi30m, tf: '30m', div: d.div30m },
    { val: d.rsi4h,  tf: '4H',  div: null },
    { val: d.rsiDaily, tf: 'D', div: null },
  ].filter(function(r) { return r.val !== null && r.val !== undefined; });
  if (rsis.length === 0) return null;
  rsis.sort(function(a, b) { return Math.abs(b.val - 50) - Math.abs(a.val - 50); });
  return rsis[0];
}

function buildRsiCompositeCell(td, d) {
  var best = getMostExtremeRSI(d);
  if (!best) { td.className = 'rsi-neutral'; td.textContent = '\u2014'; return; }

  var span = document.createElement('span');
  span.className = rsiClass(best.val);
  span.textContent = best.val.toFixed(1);
  td.appendChild(span);

  var tf = document.createElement('span');
  tf.className = 'tf-label';
  tf.textContent = ' ' + best.tf;
  td.appendChild(tf);

  // Any divergence across any timeframe
  var hasBullDiv = d.div15m === 'bull' || d.div30m === 'bull';
  var hasBearDiv = d.div15m === 'bear' || d.div30m === 'bear';
  if (hasBullDiv || hasBearDiv) {
    var dot = document.createElement('span');
    dot.style.cssText = 'display:inline-block;width:6px;height:6px;border-radius:50%;margin-left:4px;vertical-align:middle;';
    dot.style.background = hasBullDiv ? 'var(--green)' : 'var(--red)';
    dot.title = hasBullDiv ? 'Bullish divergence' : 'Bearish divergence';
    td.appendChild(dot);
  }

  // Tooltip with all RSI values
  var allRsis = [
    { val: d.rsi15m, tf: '15m', div: d.div15m },
    { val: d.rsi30m, tf: '30m', div: d.div30m },
    { val: d.rsi4h,  tf: '4H',  div: null },
    { val: d.rsiDaily, tf: 'D', div: null },
  ];
  var tipParts = [];
  for (var i = 0; i < allRsis.length; i++) {
    var r = allRsis[i];
    if (r.val !== null && r.val !== undefined) {
      var s = r.tf + ': ' + r.val.toFixed(1);
      if (r.div && r.div !== 'none') s += ' (' + r.div + ' div)';
      tipParts.push(s);
    }
  }
  td.title = tipParts.join(' | ');
}

// ── OI + Funding merged cell ──
function buildOiFundingCell(td, d) {
  td.className = 'stacked-cell';

  // OI Delta line
  var oiRow = document.createElement('div');
  if (d.oiDeltaPct !== null && d.oiDeltaPct !== undefined) {
    var lbl = getOIDeltaLabel(d.oiDeltaPct, d.change24h, d.change24h);
    var oiSpan = document.createElement('span');
    oiSpan.className = lbl.cls;
    oiSpan.textContent = lbl.label;
    oiRow.appendChild(oiSpan);
    var pctSpan = document.createElement('span');
    pctSpan.className = 'tf-label';
    pctSpan.style.marginLeft = '3px';
    pctSpan.textContent = (d.oiDeltaPct >= 0 ? '+' : '') + d.oiDeltaPct.toFixed(1) + '%';
    oiRow.appendChild(pctSpan);
  } else {
    oiRow.textContent = '\u2014';
    oiRow.style.color = 'var(--text-muted)';
  }
  td.appendChild(oiRow);

  // Funding rate line
  var frRow = document.createElement('div');
  frRow.className = 'secondary';
  var frText = formatFundingRate(d.fundingRate);
  frRow.textContent = frText;
  var frN = parseFloat(d.fundingRate);
  if (!isNaN(frN) && frN !== 0) {
    var intensity = Math.min(1, Math.abs(frN) / 0.001);
    if (frN < 0) frRow.style.color = 'rgb(50,' + Math.round(100 + 155 * intensity) + ',80)';
    else frRow.style.color = 'rgb(' + Math.round(150 + 105 * intensity) + ',70,70)';
    if (Math.abs(frN * 100) > 0.03) frRow.style.fontWeight = '700';
  }
  td.appendChild(frRow);

  // Tooltip with full details
  var tipParts = [];
  if (d.oiDeltaPct !== null) tipParts.push('OI 24h: ' + (d.oiDeltaPct >= 0 ? '+' : '') + d.oiDeltaPct.toFixed(1) + '%');
  if (d.oiDelta4h !== null) tipParts.push('OI 4h: ' + (d.oiDelta4h >= 0 ? '+' : '') + d.oiDelta4h.toFixed(1) + '%');
  tipParts.push('Funding: ' + frText);
  if (d.fundVelDir && d.fundVelDir !== 'flat') tipParts.push('Fund Vel: ' + d.fundVelDir);
  if (d.lsRatio !== null && d.lsRatio !== undefined) tipParts.push('L/S: ' + (d.lsRatio * 100).toFixed(0) + 'L/' + ((1 - d.lsRatio) * 100).toFixed(0) + 'S');
  td.title = tipParts.join(' | ');
}

// ── Squeeze cell (kept mostly as-is) ──
function buildSqueezeCell(td, d) {
  if (d.squeezeOn === undefined || d.squeezePctile === null || d.squeezePctile === undefined) {
    td.className = 'squeeze-none'; td.textContent = '\u2014'; return;
  }
  if (d.squeezeOn) { td.className = 'squeeze-active'; td.textContent = 'SQUEEZE'; return; }
  if (d.squeezeBuilding) { td.className = 'squeeze-building'; td.textContent = 'BUILDING'; return; }
  td.className = 'squeeze-none';
  td.textContent = Math.round((1 - d.squeezePctile) * 100) + '%';
}

// ── Volume cell with RVOL indicator ──
function buildVolumeCell(td, d) {
  var volText = formatVolume(d.volume24h);
  var span = document.createElement('span');
  span.textContent = volText;
  if (d.relVolume !== null && d.relVolume >= 3.0) span.style.fontWeight = '700';
  td.appendChild(span);
  if (d.relVolume !== null && d.relVolume >= 2.0) {
    var indicator = document.createElement('span');
    indicator.style.cssText = 'margin-left:4px;font-size:10px;color:var(--orange);';
    indicator.textContent = d.relVolume.toFixed(1) + 'x';
    indicator.title = 'Relative Volume: ' + d.relVolume.toFixed(1) + 'x average';
    td.appendChild(indicator);
  }
}

// ============================================================
// Table building
// ============================================================

var draggedColKey = null;

function buildHeader() {
  var tr = document.getElementById('headerRow');
  tr.innerHTML = '';
  getVisibleColumns().forEach(function(col) {
    var th = document.createElement('th');
    th.dataset.key = col.key;
    th.style.textAlign = col.align;
    var levelIdx = sortLevels.findIndex(function(s) { return s.key === col.key; });
    var isActive = levelIdx >= 0;
    var arrow = isActive ? (sortLevels[levelIdx].dir === 1 ? '\u25B2' : '\u25BC') : '\u25B2';
    var labelHTML = col.label;
    if (isActive && sortLevels.length > 1) {
      labelHTML += '<span class="sort-badge">' + (levelIdx + 1) + '</span>';
    }
    th.innerHTML = labelHTML + ' <span class="sort-arrow">' + arrow + '</span>';
    if (isActive) th.classList.add('sort-active');
    th.addEventListener('click', function(e) {
      if (th._wasDragged) { th._wasDragged = false; return; }
      onSort(col.key, e.shiftKey);
    });

    if (!col.locked) {
      th.draggable = true;
      th.addEventListener('dragstart', function(e) {
        draggedColKey = col.key;
        th.classList.add('col-dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', col.key);
      });
      th.addEventListener('dragend', function() {
        draggedColKey = null;
        th.classList.remove('col-dragging');
        tr.querySelectorAll('th').forEach(function(el) {
          el.classList.remove('col-drag-over-left', 'col-drag-over-right');
        });
      });
    }

    th.addEventListener('dragover', function(e) {
      if (!draggedColKey || draggedColKey === col.key || col.locked) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      var rect = th.getBoundingClientRect();
      var midX = rect.left + rect.width / 2;
      tr.querySelectorAll('th').forEach(function(el) {
        el.classList.remove('col-drag-over-left', 'col-drag-over-right');
      });
      if (e.clientX < midX) th.classList.add('col-drag-over-left');
      else th.classList.add('col-drag-over-right');
    });
    th.addEventListener('dragleave', function() {
      th.classList.remove('col-drag-over-left', 'col-drag-over-right');
    });
    th.addEventListener('drop', function(e) {
      e.preventDefault();
      if (!draggedColKey || draggedColKey === col.key || col.locked) return;
      var rect = th.getBoundingClientRect();
      var midX = rect.left + rect.width / 2;
      var dropBefore = e.clientX < midX;
      var fromIdx = columnOrder.indexOf(draggedColKey);
      columnOrder.splice(fromIdx, 1);
      var toIdx = columnOrder.indexOf(col.key);
      if (!dropBefore) toIdx += 1;
      columnOrder.splice(toIdx, 0, draggedColKey);
      saveColumnPrefs();
      var draggedTh = tr.querySelector('th[data-key="' + draggedColKey + '"]');
      if (draggedTh) draggedTh._wasDragged = true;
      buildHeader(); renderTable(); buildColumnPicker();
    });

    tr.appendChild(th);
  });
}

function onSort(key, addLevel) {
  if (addLevel) {
    var idx = sortLevels.findIndex(function(s) { return s.key === key; });
    if (idx >= 0) sortLevels[idx].dir *= -1;
    else sortLevels.push({ key: key, dir: -1 });
  } else {
    if (sortLevels.length === 1 && sortLevels[0].key === key) sortLevels[0].dir *= -1;
    else sortLevels = [{ key: key, dir: -1 }];
  }
  buildHeader(); renderTable();
}

function getSortedFiltered() {
  var arr = Object.values(instruments);

  if (searchText) {
    var q = searchText.toUpperCase();
    arr = arr.filter(function(d) { return d.symbol.includes(q); });
  }

  if (volumeMinFilter > 0) {
    arr = arr.filter(function(d) { return d.volume24h >= volumeMinFilter; });
  }

  // Quick filters
  if (activeFilters.has('grade-ab')) {
    arr = arr.filter(function(d) {
      var c = d._confluence;
      return c && (c.grade === 'A' || c.grade === 'B');
    });
  }
  if (activeFilters.has('ob-os')) {
    arr = arr.filter(function(d) {
      return (d.rsi15m !== null && (d.rsi15m <= 30 || d.rsi15m >= 70)) ||
             (d.rsi30m !== null && (d.rsi30m <= 30 || d.rsi30m >= 70));
    });
  }
  if (activeFilters.has('squeeze')) {
    arr = arr.filter(function(d) { return d.squeezeOn === true; });
  }

  // Advanced filters (More dropdown)
  if (activeFilters.has('divergence')) {
    arr = arr.filter(function(d) {
      return d.div15m === 'bull' || d.div15m === 'bear' || d.div30m === 'bull' || d.div30m === 'bear';
    });
  }
  if (activeFilters.has('choch-aligned')) {
    arr = arr.filter(function(d) {
      var vals = [d.choch15m, d.choch30m, d.choch4h, d.chochDaily].filter(function(v) { return v !== 'none'; });
      return vals.length >= 2 && vals.every(function(v) { return v === vals[0]; });
    });
  }
  if (activeFilters.has('oi-buildup')) {
    arr = arr.filter(function(d) {
      return d.oiDeltaPct !== null && d.oiDeltaPct !== undefined && Math.abs(d.oiDeltaPct) > 5;
    });
  }
  if (activeFilters.has('cvd-div')) {
    arr = arr.filter(function(d) {
      return d.cvdDivergence === 'bull' || d.cvdDivergence === 'bear';
    });
  }
  if (activeFilters.has('rvol')) {
    arr = arr.filter(function(d) { return d.relVolume !== null && d.relVolume > 2; });
  }

  function compareByKey(a, b, key, dir) {
    if (key === 'symbol') return dir * a.symbol.localeCompare(b.symbol);
    if (key === 'priceChange') {
      return dir * ((a.price || 0) - (b.price || 0));
    }
    if (key === 'signal') {
      var sa = a._confluence ? Math.abs(a._confluence.final) : -1;
      var sb = b._confluence ? Math.abs(b._confluence.final) : -1;
      return dir * (sa - sb);
    }
    if (key === 'rsiComposite') {
      var ra = getMostExtremeRSI(a), rb = getMostExtremeRSI(b);
      var va = ra ? Math.abs(ra.val - 50) : -1;
      var vb = rb ? Math.abs(rb.val - 50) : -1;
      return dir * (va - vb);
    }
    if (key === 'oiFunding') {
      var va = a.oiDeltaPct != null ? Math.abs(a.oiDeltaPct) : -1;
      var vb = b.oiDeltaPct != null ? Math.abs(b.oiDeltaPct) : -1;
      return dir * (va - vb);
    }
    if (key === 'squeeze') {
      var sqScore = function(d) { return d.squeezeOn ? 2 : d.squeezeBuilding ? 1 : 0; };
      return dir * (sqScore(a) - sqScore(b));
    }
    if (key === 'volume') {
      return dir * ((a.volume24h || 0) - (b.volume24h || 0));
    }
    if (key === 'relVolume') {
      return dir * ((a.relVolume || 0) - (b.relVolume || 0));
    }
    // Fallback for openInterest and other keys
    var va = a[key], vb = b[key];
    if (va == null) va = dir === 1 ? Infinity : -Infinity;
    if (vb == null) vb = dir === 1 ? Infinity : -Infinity;
    if (typeof va === 'string') va = parseFloat(va) || 0;
    if (typeof vb === 'string') vb = parseFloat(vb) || 0;
    return dir * (va - vb);
  }

  arr.sort(function(a, b) {
    // Starred symbols always first
    var aStarred = starredSymbols.has(a.symbol) ? 1 : 0;
    var bStarred = starredSymbols.has(b.symbol) ? 1 : 0;
    if (aStarred !== bStarred) return bStarred - aStarred;
    for (var li = 0; li < sortLevels.length; li++) {
      var cmp = compareByKey(a, b, sortLevels[li].key, sortLevels[li].dir);
      if (cmp !== 0) return cmp;
    }
    return 0;
  });
  return arr;
}

function renderTable() {

  var tbody = document.getElementById('tableBody');
  var arr = getSortedFiltered();
  var cols = getVisibleColumns();
  var totalCount = Object.keys(instruments).length;

  var countEl = document.getElementById('filterResultCount');
  var hasAnyFilter = activeFilters.size > 0 || volumeMinFilter > 0 || searchText;
  countEl.textContent = hasAnyFilter ? arr.length + ' / ' + totalCount : '';

  // FIX: Clear pending update timeouts before rebuilding DOM
  updateTimeouts.forEach(function(id) { clearTimeout(id); });
  updateTimeouts.clear();

  if (arr.length === 0) {
    var hint = (activeFilters.size > 0 || volumeMinFilter > 0)
      ? 'Try removing some filters to see more results.'
      : searchText ? 'No symbols match "' + searchText + '".' : '';
    tbody.innerHTML = '<tr><td colspan="' + cols.length + '" class="empty-state">' +
      'No instruments match the current filters' +
      (hint ? '<span class="empty-state-hint">' + hint + '</span>' : '') + '</td></tr>';
    return;
  }

  var frag = document.createDocumentFragment();
  for (var ai = 0; ai < arr.length; ai++) {
    var d = arr[ai];
    var tr = document.createElement('tr');
    tr.dataset.symbol = d.symbol;

    if (previousPrices[d.symbol] !== undefined && previousPrices[d.symbol] !== d.price) {
      tr.classList.add('updated');
      (function(row, sym) {
        var tid = setTimeout(function() { row.classList.remove('updated'); updateTimeouts.delete(sym); }, 2000);
        updateTimeouts.set(sym, tid);
      })(tr, d.symbol);
    }

    // Row tinting for strong signals
    var c = d._confluence;
    if (c && (c.grade === 'A' || c.grade === 'B')) {
      if (c.dir === 'LONG') tr.classList.add('signal-long-strong');
      else if (c.dir === 'SHORT') tr.classList.add('signal-short-strong');
    }

    // Starred divider: mark last starred row
    if (starredSymbols.has(d.symbol)) {
      var nextD = ai + 1 < arr.length ? arr[ai + 1] : null;
      if (!nextD || !starredSymbols.has(nextD.symbol)) tr.classList.add('starred-divider');
    }

    for (var ci = 0; ci < cols.length; ci++) {
      var col = cols[ci];
      var td = document.createElement('td');

      switch (col.key) {
        case 'symbol':        buildSymbolCell(td, d); break;
        case 'priceChange':   buildPriceChangeCell(td, d); break;
        case 'signal':        buildSignalCell(td, d); break;
        case 'rsiComposite':  buildRsiCompositeCell(td, d); break;
        case 'oiFunding':     buildOiFundingCell(td, d); break;
        case 'squeeze':       buildSqueezeCell(td, d); break;
        case 'volume':        buildVolumeCell(td, d); break;
        case 'openInterest':  td.textContent = formatVolume(d.openInterest); break;
        case 'relVolume':
          td.textContent = d.relVolume !== null ? d.relVolume.toFixed(1) + 'x' : '\u2014';
          td.className = rvolClass(d.relVolume);
          break;
      }
      tr.appendChild(td);
    }
    frag.appendChild(tr);
  }
  tbody.innerHTML = '';
  tbody.appendChild(frag);

}

// ============================================================
// Status / refresh indicators
// ============================================================

function setStatus(text, loading) {
  document.getElementById('statusText').textContent = text;
  document.getElementById('statusDot').classList.toggle('loading', !!loading);
}
function updateInstrumentCount() {
  document.getElementById('instrumentCount').textContent = Object.keys(instruments).length;
}
function setRefreshStripe(pct) {
  var stripe = document.getElementById('refreshStripe');
  var bar = document.getElementById('stripeBar');
  if (pct < 0) { stripe.classList.remove('active', 'indeterminate'); bar.style.width = '0%'; return; }
  stripe.classList.add('active'); stripe.classList.remove('indeterminate');
  bar.style.width = pct + '%';
}
function setRefreshStripeIndeterminate(on) {
  var stripe = document.getElementById('refreshStripe');
  if (on) stripe.classList.add('active', 'indeterminate');
  else stripe.classList.remove('active', 'indeterminate');
}
function setDataProgress(done, total, phase) {
  var el = document.getElementById('dataProgress');
  var txt = document.getElementById('dataProgressText');
  if (done < 0) { el.style.display = 'none'; setRefreshStripe(-1); return; }
  el.style.display = '';
  txt.textContent = (phase || 'Data') + ' ' + done + '/' + total;
  setRefreshStripe(Math.round(done / total * 100));
}
function updateLastRefresh() {
  document.getElementById('lastRefresh').textContent =
    new Date().toLocaleTimeString('en-US', { hour12: false });
}
// startCountdown() replaced by startIndicatorCountdown() in WebSocket section

// ============================================================
// Main data loading
// ============================================================

async function loadTickers() {
  setStatus('Fetching tickers...', true);
  setRefreshStripeIndeterminate(true);
  var tickers = await fetchTickers();

  previousPrices = {};
  Object.values(instruments).forEach(function(d) { previousPrices[d.symbol] = d.price; });

  tickers.forEach(function(t) {
    var sym = t.symbol;
    var existing = instruments[sym] || {};
    var price = parseFloat(t.lastPrice) || 0;
    var high24h = parseFloat(t.highPrice24h) || 0;
    var low24h = parseFloat(t.lowPrice24h) || 0;

    // P0: Compute 24h range position from real ticker data
    var rp = computePricePosition(price, high24h, low24h);

    instruments[sym] = {
      symbol: sym,
      price: price,
      change24h: parseFloat(t.price24hPcnt) * 100 || 0,
      volume24h: parseFloat(t.turnover24h) || 0,
      fundingRate: parseFloat(t.fundingRate) || 0,
      openInterest: parseFloat(t.openInterest) * price,
      high24h: high24h,
      low24h: low24h,
      rangePosition: rp.position,
      rangeAbovePct: rp.abovePct,
      rangeBelowPct: rp.belowPct,
      relVolume: existing.relVolume || null,
      rsi15m: existing.rsi15m || null,
      rsi30m: existing.rsi30m || null,
      rsi4h: existing.rsi4h || null,
      rsiDaily: existing.rsiDaily || null,
      div15m: existing.div15m || 'none',
      div30m: existing.div30m || 'none',
      choch15m: existing.choch15m || 'none',
      choch30m: existing.choch30m || 'none',
      choch4h: existing.choch4h || 'none',
      chochDaily: existing.chochDaily || 'none',
      oiDeltaPct: existing.oiDeltaPct || null,
      oiDelta4h: existing.oiDelta4h || null,
      cvdTrend: existing.cvdTrend || 'neutral',
      cvdDivergence: existing.cvdDivergence || 'none',
      squeezeOn: existing.squeezeOn || false,
      squeezeBuilding: existing.squeezeBuilding || false,
      squeezePctile: existing.squeezePctile || null,
      fundVelSlope: existing.fundVelSlope || null,
      fundVelDir: existing.fundVelDir || 'flat',
      lsRatio: existing.lsRatio || null,
      // Timeframe opens (for live change% calculation)
      _signal: existing._signal || 0,
    };
    updateSignalFor(sym);
  });

  var activeSyms = new Set(tickers.map(function(t) { return t.symbol; }));
  Object.keys(instruments).forEach(function(s) { if (!activeSyms.has(s)) delete instruments[s]; });

  updateInstrumentCount();
  setStatus('Tickers loaded', false);
  setRefreshStripeIndeterminate(false);
}

async function loadKlineDataForSymbol(symbol) {
  var intervals = [
    { key: '15', rsiKey: 'rsi15m', divKey: 'div15m', chochKey: 'choch15m' },
    { key: '30', rsiKey: 'rsi30m', divKey: 'div30m', chochKey: 'choch30m' },
    { key: '240', rsiKey: 'rsi4h', divKey: null, chochKey: 'choch4h' },
    { key: 'D', rsiKey: 'rsiDaily', divKey: null, chochKey: 'chochDaily' },
  ];
  if (!instruments[symbol]) return;

  for (var ivi = 0; ivi < intervals.length; ivi++) {
    var iv = intervals[ivi];
    try {
      var limit = iv.key === 'D' ? DAILY_KLINE_LIMIT : KLINE_LIMIT;
      var candles = await fetchKline(symbol, iv.key, limit);

      // Re-fetch inst after each await to avoid stale references
      var inst = instruments[symbol];
      if (!inst) return;

      if (!candles || candles.length < RSI_PERIOD + 2) {
        if (iv.rsiKey) inst[iv.rsiKey] = null;
        if (iv.divKey) inst[iv.divKey] = 'none';
        if (iv.chochKey) inst[iv.chochKey] = 'none';
        continue;
      }
      var closes = candles.map(function(c) { return parseFloat(c[4]); });
      var highs = candles.map(function(c) { return parseFloat(c[2]); });
      var lows = candles.map(function(c) { return parseFloat(c[3]); });
      if (iv.rsiKey) inst[iv.rsiKey] = computeRSI(closes);
      var candleObjs = candles.map(function(c, i) {
        return {
          high: highs[i], low: lows[i], close: closes[i],
          open: parseFloat(c[1]),
          volume: parseFloat(c[5]) || parseFloat(c[6]) || 0,
        };
      });
      if (iv.divKey) {
        inst[iv.divKey] = detectDivergence(candleObjs, computeRSISeries(closes));
      }
      inst[iv.chochKey] = detectCHOCH(candleObjs);

      // CVD from 4H candles
      if (iv.key === '240') {
        var cvdResult = computeCVD(candleObjs);
        inst.cvdTrend = cvdResult.trend;
        inst.cvdDivergence = cvdResult.divergence;
      }

      // Squeeze from Daily candles
      if (iv.key === 'D') {
        var sqResult = computeSqueeze(closes);
        inst.squeezeOn = sqResult.active;
        inst.squeezeBuilding = sqResult.building || false;
        inst.squeezePctile = sqResult.pctile;
      }

      // Relative volume from Daily turnover
      if (iv.key === 'D') {
        var turnovers = candles.map(function(c) { return parseFloat(c[6]); });
        if (turnovers.length >= 2) {
          var prevDays = turnovers.slice(-21, -1);
          if (prevDays.length > 0) {
            var avgVol = prevDays.reduce(function(a, b) { return a + b; }, 0) / prevDays.length;
            inst.relVolume = avgVol > 0 ? inst.volume24h / avgVol : null;
          }
        }
      }
    } catch (e) {
      console.warn('Kline failed:', symbol, iv.key, e.message);
    }
  }
  // P2: Update cached signal after kline data loads
  updateSignalFor(symbol);
}

async function loadAdditionalDataForSymbol(symbol) {
  if (!instruments[symbol]) return;

  // FIX: Removed redundant .catch() — Promise.allSettled already handles rejections
  var results = await Promise.allSettled([
    fetchOIHistory(symbol),
    fetchFundingHistory(symbol),
    fetchAccountRatio(symbol),
  ]);

  // Re-fetch inst after await to avoid stale references
  var inst = instruments[symbol];
  if (!inst) return;

  // OI Delta
  var oiHistory = results[0].status === 'fulfilled' ? results[0].value : null;
  if (oiHistory && oiHistory.length >= 2) {
    var oiDelta = computeOIDelta(oiHistory);
    inst.oiDeltaPct = oiDelta.pct24h;
    inst.oiDelta4h = oiDelta.pct4h;
  }

  // Funding Velocity
  var fundingHistory = results[1].status === 'fulfilled' ? results[1].value : null;
  if (fundingHistory && fundingHistory.length >= 3) {
    var fv = computeFundingVelocity(fundingHistory);
    inst.fundVelSlope = fv.slope;
    inst.fundVelDir = fv.dir;
  }

  // P2: L/S Ratio
  var ratioData = results[2].status === 'fulfilled' ? results[2].value : null;
  if (ratioData && ratioData.length > 0) {
    var buyRatio = parseFloat(ratioData[ratioData.length - 1].buyRatio);
    if (!isNaN(buyRatio)) inst.lsRatio = buyRatio;
  }

  // P2: Update cached signal after additional data loads
  updateSignalFor(symbol);
}

async function loadAllData(signal) {
  var symbols = Object.keys(instruments);
  var total = symbols.length;
  var done = 0;

  // Phase 1: Klines
  setDataProgress(0, total, 'Klines');
  for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
    if (signal && signal.aborted) return;
    var batch = symbols.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(function(sym) { return loadKlineDataForSymbol(sym); }));
    done += batch.length;
    setDataProgress(done, total, 'Klines');
    renderTable();
    if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
  }

  // Phase 2: OI + Funding + L/S Ratio
  done = 0;
  setDataProgress(0, total, 'OI+Fund+L/S');
  for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
    if (signal && signal.aborted) return;
    var batch = symbols.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(function(sym) { return loadAdditionalDataForSymbol(sym); }));
    done += batch.length;
    setDataProgress(done, total, 'OI+Fund+L/S');
    renderTable();
    if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
  }

  setDataProgress(-1);
  saveCache();
}

async function fullRefresh() {
  if (isRefreshing) return;
  isRefreshing = true;
  try {
    if (rsiAbortController) rsiAbortController.abort();
    rsiAbortController = new AbortController();
    await loadTickers();
    renderTable();
    updateLastRefresh();
    await loadAllData(rsiAbortController.signal);
    renderTable();
    if (!wsConnected) setStatus('Live', false);
  } catch (e) {
    setStatus('Error: ' + e.message, false);
    console.error('Refresh error:', e);
  } finally {
    isRefreshing = false;
    setRefreshStripe(-1);
  }
}

// ============================================================
// Column picker
// ============================================================

var pickerDragKey = null;

function buildColumnPicker() {
  var dropdown = document.getElementById('colPickerDropdown');
  var header = dropdown.querySelector('.picker-header');
  dropdown.innerHTML = '';
  dropdown.appendChild(header);

  getAllColumnsOrdered().forEach(function(col) {
    var item = document.createElement('label');
    item.className = 'col-picker-item' + (col.locked ? ' disabled' : '');
    item.dataset.key = col.key;

    var handle = document.createElement('span');
    handle.className = 'drag-handle'; handle.textContent = '\u2261';
    item.appendChild(handle);

    var cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = visibleColumns.has(col.key);
    if (col.locked) cb.disabled = true;
    cb.addEventListener('change', function() {
      if (col.locked) return;
      if (cb.checked) visibleColumns.add(col.key);
      else visibleColumns.delete(col.key);
      saveColumnPrefs(); buildHeader(); renderTable();
    });
    item.appendChild(cb);
    item.appendChild(document.createTextNode(col.label));

    if (!col.locked) {
      item.draggable = true;
      item.addEventListener('dragstart', function(e) {
        pickerDragKey = col.key;
        item.classList.add('picker-dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', col.key);
      });
      item.addEventListener('dragend', function() {
        pickerDragKey = null;
        item.classList.remove('picker-dragging');
        dropdown.querySelectorAll('.col-picker-item').forEach(function(el) {
          el.classList.remove('picker-drag-over');
        });
      });
    }
    item.addEventListener('dragover', function(e) {
      if (!pickerDragKey || pickerDragKey === col.key || col.locked) return;
      e.preventDefault(); e.dataTransfer.dropEffect = 'move';
      dropdown.querySelectorAll('.col-picker-item').forEach(function(el) {
        el.classList.remove('picker-drag-over');
      });
      item.classList.add('picker-drag-over');
    });
    item.addEventListener('dragleave', function() {
      item.classList.remove('picker-drag-over');
    });
    item.addEventListener('drop', function(e) {
      e.preventDefault();
      if (!pickerDragKey || pickerDragKey === col.key || col.locked) return;
      var fromIdx = columnOrder.indexOf(pickerDragKey);
      columnOrder.splice(fromIdx, 1);
      var toIdx = columnOrder.indexOf(col.key);
      columnOrder.splice(toIdx, 0, pickerDragKey);
      saveColumnPrefs(); buildColumnPicker(); buildHeader(); renderTable();
    });
    dropdown.appendChild(item);
  });
}

document.getElementById('colPickerBtn').addEventListener('click', function(e) {
  e.stopPropagation();
  document.getElementById('colPickerDropdown').classList.toggle('open');
});
document.addEventListener('click', function(e) {
  var dd = document.getElementById('colPickerDropdown');
  if (!dd.contains(e.target) && e.target !== document.getElementById('colPickerBtn')) {
    dd.classList.remove('open');
  }
});

// ============================================================
// Event handlers
// ============================================================

document.getElementById('searchInput').addEventListener('input', function(e) {
  searchText = e.target.value.trim();
  renderTable();
});

document.querySelectorAll('.filter-pill[data-filter]').forEach(function(btn) {
  btn.addEventListener('click', function() {
    var f = btn.dataset.filter;
    if (activeFilters.has(f)) { activeFilters.delete(f); btn.classList.remove('active'); }
    else { activeFilters.add(f); btn.classList.add('active'); }
    updateFilterClearBtn(); renderTable();
  });
});

document.getElementById('filterClear').addEventListener('click', function() {
  activeFilters.clear();
  document.querySelectorAll('.filter-pill').forEach(function(btn) { btn.classList.remove('active'); });
  // Reset volume dropdown
  volumeMinFilter = 0;
  document.getElementById('volFilterLabel').textContent = 'All';
  document.getElementById('volFilterBtn').classList.remove('active');
  document.querySelectorAll('#volFilterMenu button').forEach(function(b) { b.classList.remove('selected'); });
  document.querySelector('#volFilterMenu button[data-vol="0"]').classList.add('selected');
  // Reset "More" dropdown items
  document.querySelectorAll('#moreFilterMenu button').forEach(function(b) { b.classList.remove('selected'); });
  document.getElementById('moreFilterBtn').classList.remove('active');
  updateFilterClearBtn(); renderTable();
});

// ── Generic dropdown filter helper ──
function setupFilterDropdown(btnId, menuId) {
  var btn = document.getElementById(btnId);
  var menu = document.getElementById(menuId);

  btn.addEventListener('click', function(e) {
    e.stopPropagation();
    // Close other dropdown menus
    document.querySelectorAll('.filter-dropdown-menu.open').forEach(function(m) {
      if (m !== menu) m.classList.remove('open');
    });
    var isOpen = menu.classList.contains('open');
    if (!isOpen) {
      var rect = btn.getBoundingClientRect();
      menu.style.top = (rect.bottom + 4) + 'px';
      menu.style.left = rect.left + 'px';
    }
    menu.classList.toggle('open');
  });

  return { btn: btn, menu: menu };
}

// ── Volume dropdown filter ──
(function() {
  var dd = setupFilterDropdown('volFilterBtn', 'volFilterMenu');
  dd.menu.querySelectorAll('button').forEach(function(item) {
    item.addEventListener('click', function(e) {
      e.stopPropagation();
      var val = parseInt(item.dataset.vol, 10);
      volumeMinFilter = val;
      document.getElementById('volFilterLabel').textContent = val === 0 ? 'All' : item.textContent.trim();
      dd.menu.querySelectorAll('button').forEach(function(b) { b.classList.remove('selected'); });
      item.classList.add('selected');
      dd.btn.classList.toggle('active', val > 0);
      dd.menu.classList.remove('open');
      updateFilterClearBtn(); renderTable();
    });
  });
})();

// ── "More" toggle-filter dropdown ──
(function() {
  var dd = setupFilterDropdown('moreFilterBtn', 'moreFilterMenu');
  dd.menu.querySelectorAll('button').forEach(function(item) {
    item.addEventListener('click', function(e) {
      e.stopPropagation();
      var f = item.dataset.filter;
      if (activeFilters.has(f)) {
        activeFilters.delete(f); item.classList.remove('selected');
      } else {
        activeFilters.add(f); item.classList.add('selected');
      }
      // Highlight dropdown button if any sub-filter is active
      var anyActive = dd.menu.querySelector('button.selected') !== null;
      dd.btn.classList.toggle('active', anyActive);
      updateFilterClearBtn(); renderTable();
    });
  });
})();


// Close all dropdown menus when clicking outside
document.addEventListener('click', function() {
  document.querySelectorAll('.filter-dropdown-menu.open').forEach(function(m) {
    m.classList.remove('open');
  });
});

function updateFilterClearBtn() {
  document.getElementById('filterClear').classList.toggle('visible', activeFilters.size > 0 || volumeMinFilter > 0);
}

// ============================================================
// ============================================================


// Symbol click → open TradingView chart
document.getElementById('tableBody').addEventListener('click', function(e) {
  var td = e.target.closest('td');
  var tr = e.target.closest('tr');
  if (!tr || !tr.dataset.symbol) return;
  // Star icon click handled separately
  if (e.target.classList.contains('star-icon')) return;
  // Symbol cell (first cell) → open TradingView
  if (td === tr.firstElementChild) {
    var sym = tr.dataset.symbol.replace('USDT', '');
    window.open('https://www.tradingview.com/chart/?symbol=BYBIT:' + encodeURIComponent(tr.dataset.symbol) + '.P', '_blank');
  }
});

// ============================================================
// WebSocket real-time data feed
// ============================================================

function wsConnect() {
  if (wsConnection && wsConnection.readyState <= 1) return;
  try {
    wsConnection = new WebSocket(WS_URL);
  } catch (e) {
    console.error('WS connect error:', e);
    wsScheduleReconnect();
    return;
  }

  wsConnection.onopen = function() {
    wsConnected = true;
    wsReconnectAttempts = 0;
    setWsStatus('connected');
    wsStartPing();
    wsSubscribeAll();
    // Stop fallback REST polling if running
    if (wsFallbackTimer) { clearInterval(wsFallbackTimer); wsFallbackTimer = null; }
    updateLastRefresh();
  };

  wsConnection.onmessage = function(event) {
    try {
      var msg = JSON.parse(event.data);
      if (msg.op === 'pong' || msg.op === 'ping') return;
      if (msg.op === 'subscribe') {
        if (!msg.success) console.warn('WS sub failed:', msg.ret_msg);
        return;
      }
      if (msg.topic && msg.topic.startsWith('tickers.')) {
        processWsTicker(msg);
      }
    } catch (e) {
      console.warn('WS message error:', e);
    }
  };

  wsConnection.onclose = function(event) {
    wsConnected = false;
    wsStopPing();
    setWsStatus('disconnected');
    wsScheduleReconnect();
  };

  wsConnection.onerror = function() {
    console.error('WS connection error');
  };
}

function wsDisconnect() {
  if (wsConnection) {
    wsConnection.onclose = null;
    wsConnection.close();
    wsConnection = null;
  }
  wsConnected = false;
  wsStopPing();
}

function wsSend(data) {
  if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
    wsConnection.send(JSON.stringify(data));
  }
}

function wsStartPing() {
  wsStopPing();
  wsPingTimer = setInterval(function() { wsSend({ op: 'ping' }); }, WS_PING_INTERVAL);
}

function wsStopPing() {
  if (wsPingTimer) { clearInterval(wsPingTimer); wsPingTimer = null; }
}

function wsScheduleReconnect() {
  var delay = Math.min(
    WS_RECONNECT_BASE_MS * Math.pow(2, wsReconnectAttempts),
    WS_RECONNECT_MAX_MS
  );
  wsReconnectAttempts++;
  setWsStatus('reconnecting');
  console.log('WS reconnect in', delay, 'ms (attempt ' + wsReconnectAttempts + ')');

  // Start fallback REST polling after 3 failed reconnects
  if (wsReconnectAttempts >= 3 && !wsFallbackTimer) {
    console.log('WS offline — falling back to REST polling');
    wsFallbackTimer = setInterval(function() { fullRefresh(); }, REFRESH_INTERVAL);
  }

  setTimeout(wsConnect, delay);
}

function wsSubscribeAll() {
  var symbols = Object.keys(instruments);
  var topics = symbols.map(function(s) { return 'tickers.' + s; });
  for (var i = 0; i < topics.length; i += WS_SUB_BATCH) {
    wsSend({ op: 'subscribe', args: topics.slice(i, i + WS_SUB_BATCH) });
  }
  console.log('WS subscribed to', topics.length, 'ticker streams');
}

// ── Process real-time ticker updates ──

function processWsTicker(msg) {
  var data = msg.data;
  if (!data || !data.symbol) return;
  var sym = data.symbol;
  var inst = instruments[sym];
  if (!inst) return;

  // Update price with flash tracking
  if (data.lastPrice !== undefined) {
    var newPrice = parseFloat(data.lastPrice);
    if (!isNaN(newPrice) && newPrice !== inst.price) {
      previousPrices[sym] = inst.price;
      inst.price = newPrice;
    }
  }

  // Update ticker fields (delta messages only contain changed fields)
  if (data.highPrice24h !== undefined) inst.high24h = parseFloat(data.highPrice24h);
  if (data.lowPrice24h !== undefined) inst.low24h = parseFloat(data.lowPrice24h);
  if (data.price24hPcnt !== undefined) inst.change24h = parseFloat(data.price24hPcnt) * 100;
  if (data.turnover24h !== undefined) inst.volume24h = parseFloat(data.turnover24h);
  if (data.fundingRate !== undefined) inst.fundingRate = parseFloat(data.fundingRate);
  if (data.openInterest !== undefined) inst.openInterest = parseFloat(data.openInterest) * inst.price;

  // Recompute derived fields
  var rp = computePricePosition(inst.price, inst.high24h, inst.low24h);
  inst.rangePosition = rp.position;
  inst.rangeAbovePct = rp.abovePct;
  inst.rangeBelowPct = rp.belowPct;


  updateSignalFor(sym);

  // Throttled render
  dirtySymbols.add(sym);
  scheduleThrottledRender();
}

function scheduleThrottledRender() {
  if (renderThrottleTimer) return;
  renderThrottleTimer = setTimeout(function() {
    renderThrottleTimer = null;
    if (dirtySymbols.size > 0) {
      dirtySymbols.clear();
      renderTable();
      updateLastRefresh();
    }
  }, RENDER_THROTTLE_MS);
}

// ── WebSocket status display ──

function setWsStatus(state) {
  var dot = document.getElementById('statusDot');
  var text = document.getElementById('statusText');
  dot.classList.remove('loading', 'ws-live', 'ws-disconnected', 'ws-reconnecting');
  switch (state) {
    case 'connected':
      dot.classList.add('ws-live');
      text.textContent = 'Live \u2014 Streaming';
      break;
    case 'disconnected':
      dot.classList.add('ws-disconnected');
      text.textContent = 'Disconnected';
      break;
    case 'reconnecting':
      dot.classList.add('ws-reconnecting');
      text.textContent = 'Reconnecting...';
      break;
  }
}

// ============================================================
// Slow REST polls (indicators that have no WebSocket stream)
// ============================================================

async function pollKlineData() {
  try {
    var symbols = Object.keys(instruments);
    for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
      var batch = symbols.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(function(sym) { return loadKlineDataForSymbol(sym); }));
      if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
    }
    renderTable();
    saveCache();
  } catch (e) {
    console.warn('Kline poll error:', e.message);
  }
}

async function pollOIData() {
  try {
    var symbols = Object.keys(instruments);
    for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
      var batch = symbols.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(function(sym) { return loadAdditionalDataForSymbol(sym); }));
      if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
    }
    renderTable();
    saveCache();
  } catch (e) {
    console.warn('OI poll error:', e.message);
  }
}

function startIndicatorCountdown(intervalMs) {
  nextRefreshAt = Date.now() + intervalMs;
  if (countdownTimer) clearInterval(countdownTimer);
  countdownTimer = setInterval(function() {
    var remaining = Math.max(0, Math.ceil((nextRefreshAt - Date.now()) / 1000));
    var min = Math.floor(remaining / 60);
    var sec = remaining % 60;
    document.getElementById('nextRefresh').textContent =
      min > 0 ? min + ':' + (sec < 10 ? '0' : '') + sec : sec + 's';
    if (remaining <= 0) clearInterval(countdownTimer);
  }, 1000);
}

// ============================================================
// Init
// ============================================================

loadColumnPrefs();
buildHeader();
buildColumnPicker();

(async function init() {
  var hadCache = loadCache();
  if (hadCache) document.getElementById('loadingOverlay').classList.add('hidden');

  try {
    // Phase 1: Full REST bootstrap (tickers + all indicators)
    await fullRefresh();
    document.getElementById('loadingOverlay').classList.add('hidden');
  } catch (e) {
    if (!hadCache) {
      document.getElementById('loadingOverlay').textContent = 'Failed to load data: ' + e.message;
      document.getElementById('loadingOverlay').style.color = 'var(--red)';
    } else {
      setStatus('Refresh failed \u2014 showing cached data', false);
    }
  }

  // Phase 2: Start WebSocket for real-time ticker streaming
  wsConnect();

  // Phase 3: Slow REST polls for indicators (no WS stream available)
  klinePollTimer = setInterval(function() {
    pollKlineData();
    startIndicatorCountdown(KLINE_POLL_INTERVAL);
  }, KLINE_POLL_INTERVAL);

  oiPollTimer = setInterval(function() {
    pollOIData();
  }, OI_POLL_INTERVAL);

  startIndicatorCountdown(KLINE_POLL_INTERVAL);
})();
</script>
</body>
</html>
