<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bybit USDT Perpetual Screener</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0e13;
  --bg-secondary: #111820;
  --bg-tertiary: #1a2230;
  --bg-hover: #182030;
  --bg-row-alt: #0d1219;
  --border-color: #1e2a3a;
  --border-subtle: #161f2c;
  --text-primary: #d1d5db;
  --text-secondary: #7a8a9e;
  --text-muted: #3e4f65;
  --green: #22c55e;
  --green-bright: #4ade80;
  --green-dim: rgba(34,197,94,0.12);
  --green-bg: rgba(34,197,94,0.08);
  --red: #ef4444;
  --red-bright: #f87171;
  --red-dim: rgba(239,68,68,0.12);
  --red-bg: rgba(239,68,68,0.08);
  --yellow: #eab308;
  --yellow-dim: rgba(234,179,8,0.12);
  --blue: #3b82f6;
  --blue-dim: rgba(59,130,246,0.12);
  --blue-muted: rgba(59,130,246,0.06);
  --orange: #f59e0b;
  --font-mono: 'JetBrains Mono', 'SF Mono', 'Cascadia Code', 'Fira Code', Consolas, monospace;
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  --row-height: 32px;
}

html, body {
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-size: 13px;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
}

/* ── Layout ── */
.app-layout {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

/* ── Top refresh stripe (YouTube-style) ── */
.refresh-stripe {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  z-index: 999;
  background: transparent;
  overflow: hidden;
}

.refresh-stripe.active {
  background: var(--bg-tertiary);
}

.refresh-stripe .stripe-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, var(--blue), #60a5fa);
  transition: width 0.4s ease;
  border-radius: 0 1px 1px 0;
}

.refresh-stripe.indeterminate .stripe-bar {
  width: 30%;
  animation: stripe-slide 1.5s ease-in-out infinite;
}

@keyframes stripe-slide {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(400%); }
}

/* ── Header ── */
.header {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  z-index: 100;
}

.header-title {
  font-size: 14px;
  font-weight: 700;
  color: var(--text-primary);
  white-space: nowrap;
  font-family: var(--font-mono);
  letter-spacing: 0.3px;
}

.header-title span { color: var(--yellow); }

.header-divider {
  width: 1px;
  height: 24px;
  background: var(--border-color);
}

.search-box {
  position: relative;
  flex: 0 0 180px;
}

.search-box input {
  width: 100%;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 5px 10px 5px 28px;
  color: var(--text-primary);
  font-size: 12px;
  font-family: var(--font-mono);
  outline: none;
  transition: border-color 0.2s;
}

.search-box input:focus { border-color: var(--blue); }
.search-box input::placeholder { color: var(--text-muted); }

.search-box::before {
  content: '\1F50D';
  position: absolute;
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 11px;
  opacity: 0.4;
}

/* ── Filter pills ── */
.filter-bar {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  flex: 1;
}

.filter-pill {
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 10px;
  color: var(--text-secondary);
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
  font-family: var(--font-sans);
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 5px;
}

.filter-pill:hover {
  border-color: var(--text-muted);
  color: var(--text-primary);
  background: var(--bg-tertiary);
}

.filter-pill.active {
  background: var(--blue-dim);
  border-color: var(--blue);
  color: var(--blue);
}

.filter-pill.active .pill-x {
  display: inline-flex;
}

.pill-x {
  display: none;
  width: 14px;
  height: 14px;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  font-size: 10px;
  line-height: 1;
  background: rgba(59,130,246,0.2);
  color: var(--blue);
  margin-left: 2px;
}

.filter-clear {
  background: none;
  border: 1px solid transparent;
  border-radius: 4px;
  padding: 4px 8px;
  color: var(--text-muted);
  font-size: 11px;
  cursor: pointer;
  font-family: var(--font-sans);
  transition: all 0.15s;
  display: none;
}

.filter-clear.visible {
  display: inline-flex;
}

.filter-clear:hover {
  color: var(--red);
  border-color: var(--red-dim);
}

.filter-result-count {
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
  margin-left: 4px;
  font-variant-numeric: tabular-nums;
}

/* ── Column picker ── */
.col-picker-wrapper {
  position: relative;
}

.col-picker-btn {
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
  color: var(--text-secondary);
  font-size: 11px;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  gap: 4px;
  font-family: var(--font-sans);
  font-weight: 500;
}

.col-picker-btn:hover {
  border-color: var(--text-muted);
  color: var(--text-primary);
}

.col-picker-btn svg {
  width: 14px;
  height: 14px;
  opacity: 0.7;
}

.col-picker-dropdown {
  display: none;
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 6px 0;
  min-width: 180px;
  z-index: 200;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}

.col-picker-dropdown.open { display: block; }

.col-picker-dropdown .picker-header {
  padding: 6px 12px 8px;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  font-weight: 600;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 4px;
}

.col-picker-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 12px;
  cursor: pointer;
  transition: background 0.1s;
  font-size: 12px;
  color: var(--text-secondary);
}

.col-picker-item:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.col-picker-item.disabled {
  opacity: 0.4;
  cursor: default;
}

.col-picker-item input[type="checkbox"] {
  appearance: none;
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border: 1px solid var(--border-color);
  border-radius: 3px;
  background: var(--bg-primary);
  cursor: pointer;
  position: relative;
  flex-shrink: 0;
}

.col-picker-item input[type="checkbox"]:checked {
  background: var(--blue);
  border-color: var(--blue);
}

.col-picker-item input[type="checkbox"]:checked::after {
  content: '';
  position: absolute;
  top: 1px;
  left: 4px;
  width: 4px;
  height: 8px;
  border: solid #fff;
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

/* ── Status Bar ── */
.status-bar {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  padding: 4px 16px;
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 11px;
  color: var(--text-muted);
  font-family: var(--font-mono);
  font-variant-numeric: tabular-nums;
}

.status-item { display: flex; align-items: center; gap: 5px; }

.status-dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: var(--green);
  flex-shrink: 0;
}

.status-dot.loading {
  background: var(--yellow);
  animation: pulse-dot 1s ease-in-out infinite;
}

@keyframes pulse-dot {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.status-separator {
  color: var(--border-color);
}

/* ── Table Container ── */
.table-container {
  flex: 1;
  overflow: auto;
  position: relative;
  height: calc(100vh - 90px);
}

/* ── Table ── */
table {
  width: max-content;
  min-width: 100%;
  border-collapse: collapse;
  font-family: var(--font-mono);
  font-size: 12px;
  font-variant-numeric: tabular-nums lining-nums;
}

thead {
  position: sticky;
  top: 0;
  z-index: 10;
}

thead th {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border-color);
  padding: 6px 12px;
  text-align: right;
  font-weight: 600;
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.6px;
  color: var(--text-muted);
  cursor: pointer;
  user-select: none;
  white-space: nowrap;
  position: relative;
  transition: color 0.15s;
}

thead th:hover { color: var(--text-secondary); }

thead th:first-child {
  text-align: left;
  position: sticky;
  left: 0;
  z-index: 11;
  background: var(--bg-secondary);
}

thead th .sort-arrow {
  display: inline-block;
  margin-left: 3px;
  font-size: 9px;
  opacity: 0.2;
}

thead th.sort-active { color: var(--text-secondary); }
thead th.sort-active .sort-arrow { opacity: 1; color: var(--blue); }

.sort-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--blue);
  color: #fff;
  font-size: 8px;
  font-weight: 700;
  margin-left: 3px;
  vertical-align: middle;
  font-family: var(--font-mono);
}

/* ── Table rows ── */
tbody tr {
  border-bottom: 1px solid var(--border-subtle);
  transition: background 0.1s;
  height: var(--row-height);
}

tbody tr:nth-child(even) { background: var(--bg-row-alt); }
tbody tr:hover { background: var(--bg-hover); }

/* Subtle left-border tick for updated rows (replaces flash) */
tbody tr.updated td:first-child {
  box-shadow: inset 3px 0 0 var(--blue);
}

tbody tr.updated {
  transition: none;
}

tbody td {
  padding: 0 12px;
  text-align: right;
  white-space: nowrap;
  color: var(--text-primary);
  line-height: var(--row-height);
  font-size: 12px;
}

tbody td:first-child {
  text-align: left;
  font-weight: 600;
  position: sticky;
  left: 0;
  z-index: 5;
  background: var(--bg-primary);
  color: var(--text-primary);
}

tbody tr:nth-child(even) td:first-child { background: var(--bg-row-alt); }
tbody tr:hover td:first-child { background: var(--bg-hover); }

/* ── Heatmap cell backgrounds (Finviz-style) ── */
.cell-heat-green-1 { background: rgba(34,197,94,0.06); color: var(--green); }
.cell-heat-green-2 { background: rgba(34,197,94,0.10); color: var(--green-bright); }
.cell-heat-green-3 { background: rgba(34,197,94,0.16); color: var(--green-bright); font-weight: 600; }
.cell-heat-red-1   { background: rgba(239,68,68,0.06); color: var(--red); }
.cell-heat-red-2   { background: rgba(239,68,68,0.10); color: var(--red-bright); }
.cell-heat-red-3   { background: rgba(239,68,68,0.16); color: var(--red-bright); font-weight: 600; }

/* ── RSI colors ── */
.rsi-oversold { color: var(--green-bright); font-weight: 600; }
.rsi-low { color: var(--green); }
.rsi-neutral { color: var(--text-primary); }
.rsi-high { color: var(--orange); }
.rsi-overbought { color: var(--red-bright); font-weight: 600; }

/* ── Relative volume ── */
.rvol-high { color: var(--green-bright); font-weight: 600; }
.rvol-medium { color: var(--yellow); }
.rvol-normal { color: var(--text-primary); }

/* ── Change percent ── */
.change-positive { color: var(--green); }
.change-negative { color: var(--red); }

/* ── Divergence ── */
.div-bull { font-size: 12px; }
.div-bear { font-size: 12px; }
.div-none { color: var(--text-muted); }

/* ── CHOCH ── */
.choch-bull { color: var(--green); font-weight: 700; }
.choch-bear { color: var(--red); font-weight: 700; }
.choch-none { color: var(--text-muted); }
.choch-mixed { color: var(--yellow); font-weight: 700; }
.choch-aligned-badge { background: var(--blue-dim); padding: 1px 5px; border-radius: 3px; }

/* ── Condensed column styles ── */
.tf-label { font-size: 9px; color: var(--text-muted); margin-left: 2px; }
.score-high { color: var(--green-bright); font-weight: 700; }
.score-medium { color: var(--yellow); font-weight: 600; }
.score-low { color: var(--text-muted); }

/* ── Loading overlay ── */
.loading-overlay {
  position: absolute;
  inset: 0;
  background: rgba(10, 14, 19, 0.92);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 12px;
  z-index: 50;
  font-family: var(--font-mono);
  color: var(--text-secondary);
  font-size: 13px;
}

.loading-overlay.hidden { display: none; }

.spinner {
  display: inline-block;
  width: 24px;
  height: 24px;
  border: 2px solid var(--border-color);
  border-top-color: var(--blue);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* ── Empty state ── */
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-muted);
  font-size: 13px;
}

/* ── Scrollbar ── */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
::-webkit-scrollbar-corner { background: var(--bg-primary); }
</style>
</head>
<body>

<!-- Top refresh stripe -->
<div class="refresh-stripe" id="refreshStripe">
  <div class="stripe-bar" id="stripeBar"></div>
</div>

<div class="app-layout">
  <div class="header">
    <div class="header-title"><span>BYBIT</span> Futures Screener</div>
    <div class="header-divider"></div>
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="Search symbol..." spellcheck="false" />
    </div>
    <div class="header-divider"></div>
    <div class="filter-bar">
      <button class="filter-pill" data-filter="oversold">RSI &le; 30</button>
      <button class="filter-pill" data-filter="overbought">RSI &ge; 70</button>
      <button class="filter-pill" data-filter="divergence">Divergence</button>
      <button class="filter-pill" data-filter="rvol">RVol &gt; 2x</button>
      <button class="filter-pill" data-filter="choch">CHOCH</button>
      <button class="filter-pill" data-filter="choch-aligned">CHOCH Aligned</button>
      <button class="filter-clear" id="filterClear">Clear all</button>
      <span class="filter-result-count" id="filterResultCount"></span>
    </div>
    <div class="col-picker-wrapper">
      <button class="col-picker-btn" id="colPickerBtn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v18M3 12h18M5.5 5.5l13 13M18.5 5.5l-13 13"/></svg>
        Columns
      </button>
      <div class="col-picker-dropdown" id="colPickerDropdown">
        <div class="picker-header">Toggle columns</div>
      </div>
    </div>
  </div>
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Initializing...</span>
    </div>
    <span class="status-separator">&middot;</span>
    <div class="status-item"><span id="instrumentCount">0</span> instruments</div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Updated <span id="lastRefresh">&mdash;</span></div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Next <span id="nextRefresh">&mdash;</span></div>
    <div class="status-item" id="rsiProgress" style="display:none">
      <span class="status-separator">&middot;</span>
      <span id="rsiProgressText"></span>
    </div>
  </div>
  <div class="table-container" id="tableContainer">
    <div class="loading-overlay" id="loadingOverlay">
      <div class="spinner"></div>
      Loading market data...
    </div>
    <table id="mainTable">
      <thead>
        <tr id="headerRow"></tr>
      </thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
// ============================================================
// Bybit USDT Perpetual Screener — Vanilla JS
// ============================================================

const BYBIT_BASE = 'https://api.bybit.com';
const REFRESH_INTERVAL = 60000;
const BATCH_SIZE = 3;
const BATCH_DELAY = 200;
const RSI_PERIOD = 14;
const KLINE_LIMIT = 200;
const DIV_LOOKBACK = 24;
const DAILY_KLINE_LIMIT = 30;
const CACHE_KEY = 'bybit_screener_cache';
const CACHE_TS_KEY = 'bybit_screener_cache_ts';
const COL_PREFS_KEY = 'bybit_screener_columns';

// Column definitions (all available)
const ALL_COLUMNS = [
  { key: 'symbol',       label: 'Symbol',      align: 'left',  locked: true },
  { key: 'price',        label: 'Price',       align: 'right', locked: false },
  { key: 'change24h',    label: '24H Chg%',    align: 'right', locked: false },
  { key: 'volume24h',    label: '24H Vol',     align: 'right', locked: false },
  { key: 'relVolume',    label: 'Rel Vol',     align: 'right', locked: false },
  { key: 'rsiLtf',       label: 'RSI 15/30m',  align: 'right', locked: false },
  { key: 'rsiHtf',       label: 'RSI HTF',     align: 'right', locked: false },
  { key: 'choch',        label: 'CHOCH',       align: 'right', locked: false },
  { key: 'score',        label: 'Score',       align: 'right', locked: false },
  { key: 'fundingRate',  label: 'Funding',     align: 'right', locked: false },
  { key: 'openInterest', label: 'OI',          align: 'right', locked: false },
];

// Active columns (user can toggle)
let visibleColumns = new Set(ALL_COLUMNS.map(c => c.key));

function getVisibleColumns() {
  return ALL_COLUMNS.filter(c => visibleColumns.has(c.key));
}

function loadColumnPrefs() {
  try {
    const saved = localStorage.getItem(COL_PREFS_KEY);
    if (saved) {
      const arr = JSON.parse(saved);
      if (Array.isArray(arr) && arr.length > 0) {
        visibleColumns = new Set(arr);
        visibleColumns.add('symbol'); // always visible
      }
    }
  } catch (e) { /* ignore */ }
}

function saveColumnPrefs() {
  try {
    localStorage.setItem(COL_PREFS_KEY, JSON.stringify([...visibleColumns]));
  } catch (e) { /* ignore */ }
}

// State
let instruments = {};
let sortLevels = [{ key: 'score', dir: -1 }];
let activeFilters = new Set();
let searchText = '';
let refreshTimer = null;
let countdownTimer = null;
let nextRefreshAt = 0;
let isRefreshing = false;
let previousPrices = {};
let rsiAbortController = null;

// ============================================================
// LocalStorage cache
// ============================================================

function saveCache() {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(instruments));
    localStorage.setItem(CACHE_TS_KEY, String(Date.now()));
  } catch (e) {
    console.warn('Cache save failed:', e.message);
  }
}

function loadCache() {
  try {
    const data = localStorage.getItem(CACHE_KEY);
    const ts = localStorage.getItem(CACHE_TS_KEY);
    if (!data || !ts) return false;
    const parsed = JSON.parse(data);
    if (!parsed || typeof parsed !== 'object' || Object.keys(parsed).length === 0) return false;
    instruments = parsed;
    const age = Date.now() - parseInt(ts, 10);
    const ageMin = Math.round(age / 60000);
    const ageStr = ageMin < 60 ? ageMin + 'm ago' : Math.round(ageMin / 60) + 'h ago';
    setStatus('Cached (' + ageStr + ')', true);
    updateInstrumentCount();
    renderTable();
    return true;
  } catch (e) {
    console.warn('Cache load failed:', e.message);
    return false;
  }
}

// ============================================================
// API helpers
// ============================================================

async function apiFetch(path) {
  const resp = await fetch(BYBIT_BASE + path);
  if (!resp.ok) throw new Error('API error: ' + resp.status);
  const json = await resp.json();
  if (json.retCode !== 0) throw new Error('Bybit error: ' + json.retMsg);
  return json.result;
}

// ============================================================
// Data fetching
// ============================================================

async function fetchTickers() {
  const result = await apiFetch('/v5/market/tickers?category=linear');
  const list = result.list || [];
  return list.filter(t => t.symbol.endsWith('USDT'));
}

async function fetchKline(symbol, interval, limit) {
  const result = await apiFetch(
    '/v5/market/kline?category=linear&symbol=' + symbol +
    '&interval=' + interval + '&limit=' + limit
  );
  return (result.list || []).reverse();
}

// ============================================================
// Technical calculations
// ============================================================

function computeRSI(closes) {
  if (closes.length < RSI_PERIOD + 1) return null;
  let gains = 0, losses = 0;
  for (let i = 1; i <= RSI_PERIOD; i++) {
    const diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  let avgGain = gains / RSI_PERIOD;
  let avgLoss = losses / RSI_PERIOD;
  for (let i = RSI_PERIOD + 1; i < closes.length; i++) {
    const diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
  }
  if (avgLoss === 0) return 100;
  return 100 - 100 / (1 + avgGain / avgLoss);
}

function computeRSISeries(closes) {
  const rsiArr = new Array(closes.length).fill(null);
  if (closes.length < RSI_PERIOD + 1) return rsiArr;
  let gains = 0, losses = 0;
  for (let i = 1; i <= RSI_PERIOD; i++) {
    const diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  let avgGain = gains / RSI_PERIOD;
  let avgLoss = losses / RSI_PERIOD;
  rsiArr[RSI_PERIOD] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  for (let i = RSI_PERIOD + 1; i < closes.length; i++) {
    const diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
    rsiArr[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  }
  return rsiArr;
}

function detectDivergence(candles, rsiSeries) {
  const len = candles.length;
  if (len < 5) return 'none';
  const lookStart = Math.max(1, len - DIV_LOOKBACK);
  const lookEnd = len - 2;
  const swingLows = [], swingHighs = [];
  for (let i = lookStart; i <= lookEnd; i++) {
    if (rsiSeries[i] === null) continue;
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low, rsi: rsiSeries[i] });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high, rsi: rsiSeries[i] });
  }
  if (swingLows.length >= 2) {
    const recent = swingLows[swingLows.length - 1], prev = swingLows[swingLows.length - 2];
    if (recent.price < prev.price && recent.rsi > prev.rsi) return 'bull';
  }
  if (swingHighs.length >= 2) {
    const recent = swingHighs[swingHighs.length - 1], prev = swingHighs[swingHighs.length - 2];
    if (recent.price > prev.price && recent.rsi < prev.rsi) return 'bear';
  }
  return 'none';
}

function detectCHOCH(candles) {
  const len = candles.length;
  if (len < 10) return 'none';
  const swingHighs = [], swingLows = [];
  const lookStart = Math.max(1, len - 60);
  for (let i = lookStart; i < len - 1; i++) {
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high });
  }
  if (swingHighs.length < 2 || swingLows.length < 2) return 'none';
  const recentSH = swingHighs.slice(-3), recentSL = swingLows.slice(-3);
  let isDowntrend = false;
  for (let i = recentSH.length - 1; i >= 1; i--) {
    if (recentSH[i].price < recentSH[i - 1].price) { isDowntrend = true; break; }
  }
  if (isDowntrend) {
    const lastSH = recentSH[recentSH.length - 1];
    const rw = Math.min(5, len - lastSH.idx);
    for (let j = len - rw; j < len; j++) {
      if (candles[j].close > lastSH.price) return 'bull';
    }
  }
  let isUptrend = false;
  for (let i = recentSL.length - 1; i >= 1; i--) {
    if (recentSL[i].price > recentSL[i - 1].price) { isUptrend = true; break; }
  }
  if (isUptrend) {
    const lastSL = recentSL[recentSL.length - 1];
    const rw = Math.min(5, len - lastSL.idx);
    for (let j = len - rw; j < len; j++) {
      if (candles[j].close < lastSL.price) return 'bear';
    }
  }
  return 'none';
}

// ============================================================
// Number formatting
// ============================================================

function formatPrice(p) {
  const n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  if (n >= 1000) return n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  if (n >= 1) return n.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
  const s = n.toFixed(8);
  const parts = s.split('.');
  let dec = parts[1];
  while (dec.length > 4 && dec.endsWith('0')) dec = dec.slice(0, -1);
  return parts[0] + '.' + dec;
}

function formatVolume(v) {
  const n = parseFloat(v);
  if (isNaN(n)) return '\u2014';
  if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toFixed(0);
}

function formatPct(p) {
  const n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + n.toFixed(2) + '%';
}

function formatFundingRate(r) {
  const n = parseFloat(r);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + (n * 100).toFixed(4) + '%';
}

// ============================================================
// Cell rendering helpers
// ============================================================

function rsiClass(v) {
  if (v === null || v === undefined) return 'rsi-neutral';
  if (v <= 30) return 'rsi-oversold';
  if (v <= 40) return 'rsi-low';
  if (v <= 60) return 'rsi-neutral';
  if (v <= 70) return 'rsi-high';
  return 'rsi-overbought';
}

function rvolClass(v) {
  if (v === null || v === undefined) return 'rvol-normal';
  if (v > 1.5) return 'rvol-high';
  if (v >= 1.2) return 'rvol-medium';
  return 'rvol-normal';
}

function changeHeatClass(v) {
  const n = parseFloat(v);
  if (isNaN(n)) return '';
  const abs = Math.abs(n);
  if (n > 0) {
    if (abs >= 8) return 'cell-heat-green-3';
    if (abs >= 3) return 'cell-heat-green-2';
    if (abs >= 1) return 'cell-heat-green-1';
  } else if (n < 0) {
    if (abs >= 8) return 'cell-heat-red-3';
    if (abs >= 3) return 'cell-heat-red-2';
    if (abs >= 1) return 'cell-heat-red-1';
  }
  return '';
}

function fundingColor(r) {
  const n = parseFloat(r);
  if (isNaN(n)) return '';
  const intensity = Math.min(1, Math.abs(n) / 0.001);
  if (n < 0) {
    const g = Math.round(100 + 155 * intensity);
    return 'color: rgb(50,' + g + ',80)';
  } else if (n > 0) {
    const r2 = Math.round(150 + 105 * intensity);
    return 'color: rgb(' + r2 + ',70,70)';
  }
  return '';
}

function changeClass(v) {
  const n = parseFloat(v);
  if (isNaN(n)) return '';
  return n >= 0 ? 'change-positive' : 'change-negative';
}

// ============================================================
// Condensed column helpers
// ============================================================

function getMostExtremeRSI_HTF(d) {
  const rsis = [
    { val: d.rsi4h, tf: '4H' },
    { val: d.rsiDaily, tf: 'D' },
  ].filter(r => r.val !== null && r.val !== undefined);
  if (rsis.length === 0) return { val: null, tf: '' };
  rsis.sort((a, b) => Math.abs(b.val - 50) - Math.abs(a.val - 50));
  return rsis[0];
}

function getChochSummary(d) {
  const chochs = [
    { val: d.choch15m, tf: '15m' },
    { val: d.choch30m, tf: '30m' },
    { val: d.choch4h, tf: '4H' },
    { val: d.chochDaily, tf: 'D' },
  ];
  const active = chochs.filter(c => c.val !== 'none' && c.val !== undefined);
  if (active.length === 0) return { dir: 'none', count: 0, total: 4, aligned: false, tfs: [] };
  const bulls = active.filter(c => c.val === 'bull').length;
  const bears = active.filter(c => c.val === 'bear').length;
  const dir = bulls > bears ? 'bull' : bears > bulls ? 'bear' : 'mixed';
  const aligned = active.length >= 2 && active.every(c => c.val === active[0].val);
  return { dir, count: active.length, total: 4, aligned, tfs: active.map(c => c.tf) };
}

function computeScore(d) {
  let score = 0;
  const allRsi = [d.rsi15m, d.rsi30m, d.rsi4h, d.rsiDaily].filter(v => v !== null && v !== undefined);
  if (allRsi.length > 0) score += Math.min(Math.max(...allRsi.map(r => Math.abs(r - 50))), 25);
  if (d.div15m === 'bull' || d.div15m === 'bear') score += 15;
  if (d.div30m === 'bull' || d.div30m === 'bear') score += 15;
  const ch = getChochSummary(d);
  score += ch.count * 10;
  if (ch.aligned) score += 10;
  if (d.relVolume !== null && d.relVolume > 1) score += Math.min((d.relVolume - 1) * 5, 15);
  return Math.round(score);
}

function rsiLtfHTML(d) {
  const r15 = d.rsi15m, r30 = d.rsi30m, d15 = d.div15m, d30 = d.div30m;
  function rsiSpan(val, div) {
    if (val === null || val === undefined) return '<span class="rsi-neutral">\u2014</span>';
    const divIcon = div === 'bull' ? '\u{1F7E2}' : div === 'bear' ? '\u{1F534}' : '';
    return '<span class="' + rsiClass(val) + '">' + val.toFixed(1) + '</span>' +
      (divIcon ? '<span style="font-size:9px;margin-left:1px">' + divIcon + '</span>' : '');
  }
  return rsiSpan(r15, d15) + '<span class="tf-label">/</span>' + rsiSpan(r30, d30);
}

function rsiHtfHTML(d) {
  const rsi = getMostExtremeRSI_HTF(d);
  if (rsi.val === null) return '<span class="rsi-neutral">\u2014</span>';
  return '<span class="' + rsiClass(rsi.val) + '">' + rsi.val.toFixed(1) + '</span>' +
    '<span class="tf-label">' + rsi.tf + '</span>';
}

function chochCondensedHTML(d) {
  const ch = getChochSummary(d);
  if (ch.count === 0) return '<span class="choch-none">\u2014</span>';
  const cls = ch.dir === 'bull' ? 'choch-bull' : ch.dir === 'bear' ? 'choch-bear' : 'choch-mixed';
  const label = ch.dir === 'bull' ? 'BUL' : ch.dir === 'bear' ? 'BER' : 'MIX';
  let html = '<span class="' + cls + '">' + label + ' ' + ch.count + '/' + ch.total + '</span>';
  if (ch.aligned) html = '<span class="choch-aligned-badge">' + html + '</span>';
  return html;
}

function scoreHTML(score) {
  let cls = 'score-low';
  if (score >= 50) cls = 'score-high';
  else if (score >= 25) cls = 'score-medium';
  return '<span class="' + cls + '">' + score + '</span>';
}

// ============================================================
// Table building
// ============================================================

function buildHeader() {
  const tr = document.getElementById('headerRow');
  tr.innerHTML = '';
  getVisibleColumns().forEach(col => {
    const th = document.createElement('th');
    th.dataset.key = col.key;
    th.style.textAlign = col.align;
    const levelIdx = sortLevels.findIndex(s => s.key === col.key);
    const isActive = levelIdx >= 0;
    const arrow = isActive ? (sortLevels[levelIdx].dir === 1 ? '\u25B2' : '\u25BC') : '\u25B2';
    let labelHTML = col.label;
    if (isActive && sortLevels.length > 1) {
      labelHTML += '<span class="sort-badge">' + (levelIdx + 1) + '</span>';
    }
    th.innerHTML = labelHTML + ' <span class="sort-arrow">' + arrow + '</span>';
    if (isActive) th.classList.add('sort-active');
    th.addEventListener('click', (e) => onSort(col.key, e.shiftKey));
    tr.appendChild(th);
  });
}

function onSort(key, addLevel) {
  if (addLevel) {
    const idx = sortLevels.findIndex(s => s.key === key);
    if (idx >= 0) sortLevels[idx].dir *= -1;
    else sortLevels.push({ key, dir: -1 });
  } else {
    if (sortLevels.length === 1 && sortLevels[0].key === key) sortLevels[0].dir *= -1;
    else sortLevels = [{ key, dir: -1 }];
  }
  buildHeader();
  renderTable();
}

function getSortedFiltered() {
  let arr = Object.values(instruments);

  if (searchText) {
    const q = searchText.toUpperCase();
    arr = arr.filter(d => d.symbol.includes(q));
  }

  if (activeFilters.has('oversold')) {
    arr = arr.filter(d =>
      (d.rsi15m !== null && d.rsi15m <= 30) || (d.rsi30m !== null && d.rsi30m <= 30) ||
      (d.rsi4h !== null && d.rsi4h <= 30) || (d.rsiDaily !== null && d.rsiDaily <= 30));
  }
  if (activeFilters.has('overbought')) {
    arr = arr.filter(d =>
      (d.rsi15m !== null && d.rsi15m >= 70) || (d.rsi30m !== null && d.rsi30m >= 70) ||
      (d.rsi4h !== null && d.rsi4h >= 70) || (d.rsiDaily !== null && d.rsiDaily >= 70));
  }
  if (activeFilters.has('divergence')) {
    arr = arr.filter(d =>
      d.div15m === 'bull' || d.div15m === 'bear' || d.div30m === 'bull' || d.div30m === 'bear');
  }
  if (activeFilters.has('rvol')) {
    arr = arr.filter(d => d.relVolume !== null && d.relVolume > 2);
  }
  if (activeFilters.has('choch')) {
    arr = arr.filter(d =>
      d.choch15m !== 'none' || d.choch30m !== 'none' || d.choch4h !== 'none' || d.chochDaily !== 'none');
  }
  if (activeFilters.has('choch-aligned')) {
    arr = arr.filter(d => {
      const vals = [d.choch15m, d.choch30m, d.choch4h, d.chochDaily].filter(v => v !== 'none');
      return vals.length >= 2 && vals.every(v => v === vals[0]);
    });
  }

  arr.forEach(d => { d._score = computeScore(d); });

  function compareByKey(a, b, key, dir) {
    if (key === 'symbol') return dir * a.symbol.localeCompare(b.symbol);
    if (key === 'rsiLtf') {
      const ea = [a.rsi15m, a.rsi30m].filter(v => v !== null && v !== undefined);
      const eb = [b.rsi15m, b.rsi30m].filter(v => v !== null && v !== undefined);
      const va = ea.length > 0 ? Math.max(...ea.map(r => Math.abs(r - 50))) : -1;
      const vb = eb.length > 0 ? Math.max(...eb.map(r => Math.abs(r - 50))) : -1;
      return dir * (va - vb);
    }
    if (key === 'rsiHtf') {
      const ra = getMostExtremeRSI_HTF(a), rb = getMostExtremeRSI_HTF(b);
      return dir * ((ra.val !== null ? Math.abs(ra.val - 50) : -1) - (rb.val !== null ? Math.abs(rb.val - 50) : -1));
    }
    if (key === 'choch') {
      const ca = getChochSummary(a), cb = getChochSummary(b);
      return dir * ((ca.count + (ca.aligned ? 0.5 : 0)) - (cb.count + (cb.aligned ? 0.5 : 0)));
    }
    if (key === 'score') return dir * (a._score - b._score);
    let va = a[key], vb = b[key];
    if (va === null || va === undefined) va = dir === 1 ? Infinity : -Infinity;
    if (vb === null || vb === undefined) vb = dir === 1 ? Infinity : -Infinity;
    if (typeof va === 'string') va = parseFloat(va) || 0;
    if (typeof vb === 'string') vb = parseFloat(vb) || 0;
    return dir * (va - vb);
  }

  arr.sort((a, b) => {
    for (const level of sortLevels) {
      const cmp = compareByKey(a, b, level.key, level.dir);
      if (cmp !== 0) return cmp;
    }
    return 0;
  });

  return arr;
}

function renderTable() {
  const tbody = document.getElementById('tableBody');
  const arr = getSortedFiltered();
  const cols = getVisibleColumns();
  const totalCount = Object.keys(instruments).length;

  // Update filter result count
  const countEl = document.getElementById('filterResultCount');
  if (activeFilters.size > 0 || searchText) {
    countEl.textContent = arr.length + ' / ' + totalCount;
  } else {
    countEl.textContent = '';
  }

  if (arr.length === 0) {
    tbody.innerHTML = '<tr><td colspan="' + cols.length +
      '" class="empty-state">No instruments match the current filters</td></tr>';
    return;
  }

  const frag = document.createDocumentFragment();
  arr.forEach(d => {
    const tr = document.createElement('tr');
    tr.dataset.symbol = d.symbol;

    // Subtle left-border tick for updated prices (replaces flash)
    if (previousPrices[d.symbol] !== undefined && previousPrices[d.symbol] !== d.price) {
      tr.classList.add('updated');
      setTimeout(() => tr.classList.remove('updated'), 2000);
    }

    cols.forEach(col => {
      const td = document.createElement('td');

      switch (col.key) {
        case 'symbol':
          td.textContent = d.symbol;
          break;
        case 'price':
          td.textContent = formatPrice(d.price);
          break;
        case 'change24h':
          td.textContent = formatPct(d.change24h);
          const heatCls = changeHeatClass(d.change24h);
          if (heatCls) td.className = heatCls;
          else td.className = changeClass(d.change24h);
          break;
        case 'volume24h':
          td.textContent = formatVolume(d.volume24h);
          break;
        case 'relVolume':
          if (d.relVolume !== null) {
            td.textContent = d.relVolume.toFixed(1) + 'x';
            td.className = rvolClass(d.relVolume);
          } else {
            td.textContent = '\u2014';
            td.className = 'rvol-normal';
          }
          break;
        case 'rsiLtf':
          td.innerHTML = rsiLtfHTML(d);
          break;
        case 'rsiHtf':
          td.innerHTML = rsiHtfHTML(d);
          break;
        case 'choch':
          td.innerHTML = chochCondensedHTML(d);
          break;
        case 'score':
          td.innerHTML = scoreHTML(d._score);
          break;
        case 'fundingRate':
          td.textContent = formatFundingRate(d.fundingRate);
          const fc = fundingColor(d.fundingRate);
          if (fc) td.setAttribute('style', fc);
          break;
        case 'openInterest':
          td.textContent = formatVolume(d.openInterest);
          break;
      }
      tr.appendChild(td);
    });

    frag.appendChild(tr);
  });

  tbody.innerHTML = '';
  tbody.appendChild(frag);
}

// ============================================================
// Status / refresh indicators
// ============================================================

function setStatus(text, loading) {
  document.getElementById('statusText').textContent = text;
  document.getElementById('statusDot').classList.toggle('loading', !!loading);
}

function updateInstrumentCount() {
  document.getElementById('instrumentCount').textContent = Object.keys(instruments).length;
}

function setRefreshStripe(pct) {
  const stripe = document.getElementById('refreshStripe');
  const bar = document.getElementById('stripeBar');
  if (pct < 0) {
    stripe.classList.remove('active', 'indeterminate');
    bar.style.width = '0%';
    return;
  }
  stripe.classList.add('active');
  stripe.classList.remove('indeterminate');
  bar.style.width = pct + '%';
}

function setRefreshStripeIndeterminate(on) {
  const stripe = document.getElementById('refreshStripe');
  if (on) {
    stripe.classList.add('active', 'indeterminate');
  } else {
    stripe.classList.remove('active', 'indeterminate');
  }
}

function setRSIProgress(done, total) {
  const el = document.getElementById('rsiProgress');
  const txt = document.getElementById('rsiProgressText');
  if (done < 0) { el.style.display = 'none'; setRefreshStripe(-1); return; }
  el.style.display = '';
  txt.textContent = 'RSI ' + done + '/' + total;
  setRefreshStripe(Math.round(done / total * 100));
}

function updateLastRefresh() {
  document.getElementById('lastRefresh').textContent =
    new Date().toLocaleTimeString('en-US', { hour12: false });
}

function startCountdown() {
  nextRefreshAt = Date.now() + REFRESH_INTERVAL;
  if (countdownTimer) clearInterval(countdownTimer);
  countdownTimer = setInterval(() => {
    const remaining = Math.max(0, Math.ceil((nextRefreshAt - Date.now()) / 1000));
    document.getElementById('nextRefresh').textContent = remaining + 's';
    if (remaining <= 0) clearInterval(countdownTimer);
  }, 1000);
}

// ============================================================
// Main data loading
// ============================================================

async function loadTickers() {
  setStatus('Fetching tickers...', true);
  setRefreshStripeIndeterminate(true);
  const tickers = await fetchTickers();

  previousPrices = {};
  Object.values(instruments).forEach(d => { previousPrices[d.symbol] = d.price; });

  tickers.forEach(t => {
    const sym = t.symbol;
    const existing = instruments[sym] || {};
    instruments[sym] = {
      symbol: sym,
      price: parseFloat(t.lastPrice) || 0,
      change24h: parseFloat(t.price24hPcnt) * 100 || 0,
      volume24h: parseFloat(t.turnover24h) || 0,
      fundingRate: parseFloat(t.fundingRate) || 0,
      openInterest: parseFloat(t.openInterest) * (parseFloat(t.lastPrice) || 0),
      relVolume: existing.relVolume || null,
      rsi15m: existing.rsi15m || null,
      rsi30m: existing.rsi30m || null,
      rsi4h: existing.rsi4h || null,
      rsiDaily: existing.rsiDaily || null,
      div15m: existing.div15m || 'none',
      div30m: existing.div30m || 'none',
      choch15m: existing.choch15m || 'none',
      choch30m: existing.choch30m || 'none',
      choch4h: existing.choch4h || 'none',
      chochDaily: existing.chochDaily || 'none',
    };
  });

  const activeSyms = new Set(tickers.map(t => t.symbol));
  Object.keys(instruments).forEach(s => { if (!activeSyms.has(s)) delete instruments[s]; });

  updateInstrumentCount();
  setStatus('Tickers loaded', false);
  setRefreshStripeIndeterminate(false);
}

async function loadKlineDataForSymbol(symbol) {
  const intervals = [
    { key: '15', rsiKey: 'rsi15m', divKey: 'div15m', chochKey: 'choch15m' },
    { key: '30', rsiKey: 'rsi30m', divKey: 'div30m', chochKey: 'choch30m' },
    { key: '240', rsiKey: 'rsi4h', divKey: null, chochKey: 'choch4h' },
    { key: 'D', rsiKey: 'rsiDaily', divKey: null, chochKey: 'chochDaily' },
  ];
  const inst = instruments[symbol];
  if (!inst) return;

  for (const iv of intervals) {
    try {
      const candles = await fetchKline(symbol, iv.key, KLINE_LIMIT);
      if (!candles || candles.length < RSI_PERIOD + 2) {
        inst[iv.rsiKey] = null;
        if (iv.divKey) inst[iv.divKey] = 'none';
        inst[iv.chochKey] = 'none';
        continue;
      }
      const closes = candles.map(c => parseFloat(c[4]));
      const highs = candles.map(c => parseFloat(c[2]));
      const lows = candles.map(c => parseFloat(c[3]));
      inst[iv.rsiKey] = computeRSI(closes);
      const candleObjs = candles.map((c, i) => ({ high: highs[i], low: lows[i], close: closes[i] }));
      if (iv.divKey) {
        inst[iv.divKey] = detectDivergence(candleObjs, computeRSISeries(closes));
      }
      inst[iv.chochKey] = detectCHOCH(candleObjs);
      if (iv.key === 'D') {
        const turnovers = candles.map(c => parseFloat(c[6]));
        if (turnovers.length >= 2) {
          const prevDays = turnovers.slice(-21, -1);
          if (prevDays.length > 0) {
            const avgVol = prevDays.reduce((a, b) => a + b, 0) / prevDays.length;
            inst.relVolume = avgVol > 0 ? inst.volume24h / avgVol : null;
          }
        }
      }
    } catch (e) {
      console.warn('Kline fetch failed for', symbol, iv.key, e.message);
    }
  }
}

async function loadAllKlineData(signal) {
  const symbols = Object.keys(instruments);
  const total = symbols.length;
  let done = 0;
  setRSIProgress(0, total);

  for (let i = 0; i < symbols.length; i += BATCH_SIZE) {
    if (signal && signal.aborted) return;
    const batch = symbols.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(sym => loadKlineDataForSymbol(sym)));
    done += batch.length;
    setRSIProgress(done, total);
    renderTable();
    if (i + BATCH_SIZE < symbols.length) await new Promise(r => setTimeout(r, BATCH_DELAY));
  }

  setRSIProgress(-1);
  saveCache();
}

async function fullRefresh() {
  if (isRefreshing) return;
  isRefreshing = true;
  try {
    if (rsiAbortController) rsiAbortController.abort();
    rsiAbortController = new AbortController();
    await loadTickers();
    renderTable();
    updateLastRefresh();
    await loadAllKlineData(rsiAbortController.signal);
    setStatus('Live', false);
  } catch (e) {
    setStatus('Error: ' + e.message, false);
    console.error('Refresh error:', e);
  } finally {
    isRefreshing = false;
    setRefreshStripe(-1);
    startCountdown();
  }
}

// ============================================================
// Column picker
// ============================================================

function buildColumnPicker() {
  const dropdown = document.getElementById('colPickerDropdown');
  // Clear existing items (keep header)
  const header = dropdown.querySelector('.picker-header');
  dropdown.innerHTML = '';
  dropdown.appendChild(header);

  ALL_COLUMNS.forEach(col => {
    const item = document.createElement('label');
    item.className = 'col-picker-item' + (col.locked ? ' disabled' : '');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = visibleColumns.has(col.key);
    if (col.locked) cb.disabled = true;
    cb.addEventListener('change', () => {
      if (col.locked) return;
      if (cb.checked) visibleColumns.add(col.key);
      else visibleColumns.delete(col.key);
      saveColumnPrefs();
      buildHeader();
      renderTable();
    });
    item.appendChild(cb);
    item.appendChild(document.createTextNode(col.label));
    dropdown.appendChild(item);
  });
}

document.getElementById('colPickerBtn').addEventListener('click', (e) => {
  e.stopPropagation();
  const dropdown = document.getElementById('colPickerDropdown');
  dropdown.classList.toggle('open');
});

// Close dropdown on outside click
document.addEventListener('click', (e) => {
  const dropdown = document.getElementById('colPickerDropdown');
  if (!dropdown.contains(e.target) && e.target !== document.getElementById('colPickerBtn')) {
    dropdown.classList.remove('open');
  }
});

// ============================================================
// Event handlers
// ============================================================

document.getElementById('searchInput').addEventListener('input', (e) => {
  searchText = e.target.value.trim();
  renderTable();
});

// Filter pills
document.querySelectorAll('.filter-pill').forEach(btn => {
  btn.addEventListener('click', () => {
    const f = btn.dataset.filter;
    if (activeFilters.has(f)) {
      activeFilters.delete(f);
      btn.classList.remove('active');
    } else {
      activeFilters.add(f);
      btn.classList.add('active');
    }
    updateFilterClearBtn();
    renderTable();
  });
});

// Clear all filters
document.getElementById('filterClear').addEventListener('click', () => {
  activeFilters.clear();
  document.querySelectorAll('.filter-pill').forEach(btn => btn.classList.remove('active'));
  updateFilterClearBtn();
  renderTable();
});

function updateFilterClearBtn() {
  document.getElementById('filterClear').classList.toggle('visible', activeFilters.size > 0);
}

// ============================================================
// Init
// ============================================================

loadColumnPrefs();
buildHeader();
buildColumnPicker();

(async function init() {
  const hadCache = loadCache();
  if (hadCache) document.getElementById('loadingOverlay').classList.add('hidden');

  try {
    await fullRefresh();
    document.getElementById('loadingOverlay').classList.add('hidden');
  } catch (e) {
    if (!hadCache) {
      document.getElementById('loadingOverlay').innerHTML =
        '<span style="color:var(--red)">Failed to load data: ' + e.message + '</span>';
    } else {
      setStatus('Refresh failed \u2014 showing cached data', false);
    }
  }
  refreshTimer = setInterval(() => fullRefresh(), REFRESH_INTERVAL);
})();
</script>
</body>
</html>
