<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MelloScan — Bybit Futures Screener</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0e13;
  --bg-secondary: #111820;
  --bg-tertiary: #1a2230;
  --bg-hover: #182030;
  --bg-row-alt: #0d1219;
  --border-color: #1e2a3a;
  --border-subtle: #161f2c;
  --text-primary: #d1d5db;
  --text-secondary: #7a8a9e;
  --text-muted: #3e4f65;
  --green: #22c55e;
  --green-bright: #4ade80;
  --green-dim: rgba(34,197,94,0.12);
  --green-bg: rgba(34,197,94,0.08);
  --red: #ef4444;
  --red-bright: #f87171;
  --red-dim: rgba(239,68,68,0.12);
  --red-bg: rgba(239,68,68,0.08);
  --yellow: #eab308;
  --yellow-dim: rgba(234,179,8,0.12);
  --blue: #3b82f6;
  --blue-dim: rgba(59,130,246,0.12);
  --blue-muted: rgba(59,130,246,0.06);
  --orange: #f59e0b;
  --font-mono: 'JetBrains Mono', 'SF Mono', 'Cascadia Code', 'Fira Code', Consolas, monospace;
  --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  --row-height: 32px;
}

html, body {
  height: 100%;
  background: var(--bg-primary);
  color: var(--text-primary);
  font-family: var(--font-sans);
  font-size: 13px;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
}

/* ── Layout ── */
.app-layout { display: flex; flex-direction: column; height: 100vh; }

/* ── Refresh stripe ── */
.refresh-stripe {
  position: fixed; top: 0; left: 0; right: 0; height: 2px; z-index: 999;
  background: transparent; overflow: hidden;
}
.refresh-stripe.active { background: var(--bg-tertiary); }
.refresh-stripe .stripe-bar {
  height: 100%; width: 0%;
  background: linear-gradient(90deg, var(--blue), #60a5fa);
  transition: width 0.4s ease; border-radius: 0 1px 1px 0;
}
.refresh-stripe.indeterminate .stripe-bar {
  width: 30%; animation: stripe-slide 1.5s ease-in-out infinite;
}
@keyframes stripe-slide {
  0% { transform: translateX(-100%); } 100% { transform: translateX(400%); }
}

/* ── Header ── */
.header {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 10px 16px; display: flex; align-items: center; gap: 12px;
  flex-wrap: wrap; z-index: 100;
}
.brand { display: flex; align-items: center; gap: 8px; white-space: nowrap; }
.brand-icon { color: var(--blue); flex-shrink: 0; }
.brand-name {
  font-size: 15px; font-weight: 800; color: var(--text-primary);
  font-family: var(--font-mono); letter-spacing: 0.5px;
}
.brand-name span { color: var(--blue); }
.brand-sub {
  font-size: 10px; color: var(--text-muted); font-family: var(--font-sans);
  margin-left: 4px; font-weight: 400; letter-spacing: 0.3px;
}
.header-divider { width: 1px; height: 24px; background: var(--border-color); }

/* ── Search ── */
.search-box { position: relative; flex: 0 0 180px; }
.search-box input {
  width: 100%; background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 5px 10px 5px 28px; color: var(--text-primary);
  font-size: 12px; font-family: var(--font-mono); outline: none;
  transition: border-color 0.2s;
}
.search-box input:focus { border-color: var(--blue); }
.search-box input::placeholder { color: var(--text-muted); }
.search-box::before {
  content: '\1F50D'; position: absolute; left: 8px; top: 50%;
  transform: translateY(-50%); font-size: 11px; opacity: 0.4;
}

/* ── Filter pills ── */
.filter-bar {
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap; flex: 1;
}
.filter-sep {
  width: 1px; height: 18px; background: var(--border-color);
  margin: 0 2px; flex-shrink: 0;
}
.filter-pill {
  background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 4px 10px; color: var(--text-secondary);
  font-size: 11px; cursor: pointer; transition: all 0.15s; white-space: nowrap;
  font-family: var(--font-sans); font-weight: 500;
  display: flex; align-items: center; gap: 5px;
}
.filter-pill:hover {
  border-color: var(--text-muted); color: var(--text-primary);
  background: var(--bg-tertiary);
}
.filter-pill.active {
  background: var(--blue-dim); border-color: var(--blue); color: var(--blue);
}
.filter-pill.active .pill-x { display: inline-flex; }
.pill-x {
  display: none; width: 14px; height: 14px; align-items: center;
  justify-content: center; border-radius: 50%; font-size: 10px; line-height: 1;
  background: rgba(59,130,246,0.2); color: var(--blue); margin-left: 2px;
}
.filter-clear {
  background: none; border: 1px solid transparent; border-radius: 4px;
  padding: 4px 8px; color: var(--text-muted); font-size: 11px; cursor: pointer;
  font-family: var(--font-sans); transition: all 0.15s; display: none;
}
.filter-clear.visible { display: inline-flex; }
.filter-clear:hover { color: var(--red); border-color: var(--red-dim); }
.filter-result-count {
  font-size: 11px; color: var(--text-muted); font-family: var(--font-mono);
  margin-left: 4px; font-variant-numeric: tabular-nums;
}

/* ── Column picker ── */
.col-picker-wrapper { position: relative; }
.col-picker-btn {
  background: var(--bg-primary); border: 1px solid var(--border-color);
  border-radius: 4px; padding: 4px 8px; color: var(--text-secondary);
  font-size: 11px; cursor: pointer; transition: all 0.15s;
  display: flex; align-items: center; gap: 4px;
  font-family: var(--font-sans); font-weight: 500;
}
.col-picker-btn:hover { border-color: var(--text-muted); color: var(--text-primary); }
.col-picker-btn svg { width: 14px; height: 14px; opacity: 0.7; }
.col-picker-dropdown {
  display: none; position: absolute; top: calc(100% + 4px); right: 0;
  background: var(--bg-secondary); border: 1px solid var(--border-color);
  border-radius: 6px; padding: 6px 0; min-width: 180px; z-index: 200;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4); max-height: 400px; overflow-y: auto;
}
.col-picker-dropdown.open { display: block; }
.col-picker-dropdown .picker-header {
  padding: 6px 12px 8px; font-size: 10px; text-transform: uppercase;
  letter-spacing: 0.5px; color: var(--text-muted); font-weight: 600;
  border-bottom: 1px solid var(--border-color); margin-bottom: 4px;
}
.col-picker-item {
  display: flex; align-items: center; gap: 8px; padding: 5px 12px;
  cursor: pointer; transition: background 0.1s; font-size: 12px;
  color: var(--text-secondary); position: relative;
}
.col-picker-item:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.col-picker-item.disabled { opacity: 0.4; cursor: default; }
.col-picker-item input[type="checkbox"] {
  appearance: none; -webkit-appearance: none; width: 14px; height: 14px;
  border: 1px solid var(--border-color); border-radius: 3px;
  background: var(--bg-primary); cursor: pointer; position: relative; flex-shrink: 0;
}
.col-picker-item input[type="checkbox"]:checked {
  background: var(--blue); border-color: var(--blue);
}
.col-picker-item input[type="checkbox"]:checked::after {
  content: ''; position: absolute; top: 1px; left: 4px;
  width: 4px; height: 8px; border: solid #fff; border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

/* ── Column drag-and-drop ── */
thead th[draggable="true"] { cursor: grab; }
thead th[draggable="true"]:active { cursor: grabbing; }
thead th.col-dragging { opacity: 0.35; background: var(--bg-tertiary); }
thead th.col-drag-over-left { box-shadow: inset 3px 0 0 var(--blue); }
thead th.col-drag-over-right { box-shadow: inset -3px 0 0 var(--blue); }
.col-picker-item[draggable="true"] { cursor: grab; }
.col-picker-item[draggable="true"]:active { cursor: grabbing; }
.col-picker-item.picker-dragging { opacity: 0.35; background: var(--bg-tertiary); }
.col-picker-item.picker-drag-over { border-top: 2px solid var(--blue); }
.col-picker-item .drag-handle {
  display: flex; align-items: center; color: var(--text-muted);
  font-size: 11px; flex-shrink: 0; cursor: grab; padding: 0 2px;
  letter-spacing: 1px; line-height: 1; user-select: none;
}
.col-picker-item.disabled .drag-handle { visibility: hidden; }

/* ── Status Bar ── */
.status-bar {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 4px 16px; display: flex; align-items: center; gap: 16px;
  font-size: 11px; color: var(--text-muted); font-family: var(--font-mono);
  font-variant-numeric: tabular-nums;
}
.status-item { display: flex; align-items: center; gap: 5px; }
.status-dot {
  width: 6px; height: 6px; border-radius: 50%;
  background: var(--green); flex-shrink: 0;
}
.status-dot.loading {
  background: var(--yellow); animation: pulse-dot 1s ease-in-out infinite;
}
.status-dot.ws-live {
  background: var(--green); box-shadow: 0 0 6px rgba(34,197,94,0.5);
}
.status-dot.ws-disconnected { background: var(--red); }
.status-dot.ws-reconnecting {
  background: var(--yellow); animation: pulse-dot 1.5s ease-in-out infinite;
}
@keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
.status-separator { color: var(--border-color); }

/* ── Table Container ── */
.table-container {
  flex: 1; overflow: auto; position: relative; height: calc(100vh - 90px);
}

/* ── Table ── */
table {
  width: max-content; min-width: 100%; border-collapse: collapse;
  font-family: var(--font-mono); font-size: 12px;
  font-variant-numeric: tabular-nums lining-nums;
}
thead { position: sticky; top: 0; z-index: 10; }
thead th {
  background: var(--bg-secondary); border-bottom: 1px solid var(--border-color);
  padding: 6px 12px; text-align: right; font-weight: 600; font-size: 10px;
  text-transform: uppercase; letter-spacing: 0.6px; color: var(--text-muted);
  cursor: pointer; user-select: none; white-space: nowrap; position: relative;
  transition: color 0.15s;
}
thead th:hover { color: var(--text-secondary); }
thead th:first-child {
  text-align: left; position: sticky; left: 0; z-index: 11;
  background: var(--bg-secondary);
}
thead th .sort-arrow {
  display: inline-block; margin-left: 3px; font-size: 9px; opacity: 0.2;
}
thead th.sort-active { color: var(--text-secondary); }
thead th.sort-active .sort-arrow { opacity: 1; color: var(--blue); }
.sort-badge {
  display: inline-flex; align-items: center; justify-content: center;
  width: 14px; height: 14px; border-radius: 50%; background: var(--blue);
  color: #fff; font-size: 8px; font-weight: 700; margin-left: 3px;
  vertical-align: middle; font-family: var(--font-mono);
}

/* ── Table rows ── */
tbody tr {
  border-bottom: 1px solid var(--border-subtle);
  transition: background 0.1s; height: var(--row-height);
}
tbody tr:nth-child(even) { background: var(--bg-row-alt); }
tbody tr:hover { background: var(--bg-hover); }
tbody tr.updated td:first-child { box-shadow: inset 3px 0 0 var(--blue); }
tbody tr.updated { transition: none; }
tbody td {
  padding: 0 12px; text-align: right; white-space: nowrap;
  color: var(--text-primary); line-height: var(--row-height); font-size: 12px;
}
tbody td:first-child {
  text-align: left; font-weight: 600; position: sticky; left: 0; z-index: 5;
  background: var(--bg-primary); color: var(--text-primary);
}
tbody tr:nth-child(even) td:first-child { background: var(--bg-row-alt); }
tbody tr:hover td:first-child { background: var(--bg-hover); }

/* ── Heatmap cells ── */
.cell-heat-green-1 { background: rgba(34,197,94,0.06); color: var(--green); }
.cell-heat-green-2 { background: rgba(34,197,94,0.10); color: var(--green-bright); }
.cell-heat-green-3 { background: rgba(34,197,94,0.16); color: var(--green-bright); font-weight: 600; }
.cell-heat-red-1   { background: rgba(239,68,68,0.06); color: var(--red); }
.cell-heat-red-2   { background: rgba(239,68,68,0.10); color: var(--red-bright); }
.cell-heat-red-3   { background: rgba(239,68,68,0.16); color: var(--red-bright); font-weight: 600; }

/* ── RSI ── */
.rsi-oversold { color: var(--green-bright); font-weight: 600; }
.rsi-low { color: var(--green); }
.rsi-neutral { color: var(--text-primary); }
.rsi-high { color: var(--orange); }
.rsi-overbought { color: var(--red-bright); font-weight: 600; }

/* ── Relative volume ── */
.rvol-high { color: var(--green-bright); font-weight: 600; }
.rvol-medium { color: var(--yellow); }
.rvol-normal { color: var(--text-primary); }

/* ── Change percent ── */
.change-positive { color: var(--green); }
.change-negative { color: var(--red); }

/* ── Condensed ── */
.tf-label { font-size: 9px; color: var(--text-muted); margin-left: 2px; }

/* ── Signal badges ── */
.signal-badge {
  display: inline-block; padding: 1px 6px; border-radius: 3px;
  font-size: 10px; font-weight: 700; letter-spacing: 0.3px;
  font-family: var(--font-mono); line-height: 18px; white-space: nowrap;
}
.signal-strong-long {
  background: rgba(34,197,94,0.18); color: var(--green-bright);
  border: 1px solid rgba(34,197,94,0.30);
}
.signal-long { background: rgba(34,197,94,0.08); color: var(--green); }
.signal-neutral { color: var(--text-muted); }
.signal-short { background: rgba(239,68,68,0.08); color: var(--red); }
.signal-strong-short {
  background: rgba(239,68,68,0.18); color: var(--red-bright);
  border: 1px solid rgba(239,68,68,0.30);
}
.signal-score {
  font-size: 9px; color: var(--text-muted); margin-left: 4px; font-weight: 400;
}

/* ── Setup Grade ── */
.grade-badge {
  display: inline-block; padding: 1px 6px; border-radius: 3px;
  font-size: 11px; font-weight: 700; letter-spacing: 0.3px;
  font-family: var(--font-mono); line-height: 18px; white-space: nowrap;
}
.grade-A {
  background: rgba(34,197,94,0.22); color: #4ade80;
  border: 1px solid rgba(34,197,94,0.35); text-shadow: 0 0 6px rgba(34,197,94,0.3);
}
.grade-B {
  background: rgba(34,197,94,0.10); color: var(--green);
  border: 1px solid rgba(34,197,94,0.18);
}
.grade-C {
  background: rgba(234,179,8,0.10); color: var(--yellow);
  border: 1px solid rgba(234,179,8,0.15);
}
.grade-D { color: var(--text-secondary); }
.grade-F { color: var(--text-muted); }
.grade-dir {
  font-size: 9px; color: var(--text-secondary); margin-left: 3px; font-weight: 400;
}
.grade-score {
  font-size: 9px; color: var(--text-muted); margin-left: 3px; font-weight: 400;
}

/* ── OI Delta ── */
.oi-new-long { color: var(--green-bright); font-weight: 600; }
.oi-new-short { color: var(--red-bright); font-weight: 600; }
.oi-short-cover { color: var(--yellow); }
.oi-liq-long { color: var(--orange); }
.oi-flat { color: var(--text-muted); }

/* ── 24h Range Position ── */
.range-at-high { color: var(--red-bright); font-weight: 600; }
.range-upper { color: var(--orange); }
.range-mid { color: var(--text-primary); }
.range-lower { color: var(--green); }
.range-at-low { color: var(--green-bright); font-weight: 600; }

/* ── CVD ── */
.cvd-bull { color: var(--green); }
.cvd-bear { color: var(--red); }
.cvd-neutral { color: var(--text-muted); }

/* ── Squeeze ── */
.squeeze-active {
  color: var(--yellow); font-weight: 700;
  background: rgba(234,179,8,0.10); padding: 1px 5px; border-radius: 3px;
}
.squeeze-building { color: var(--orange); }
.squeeze-none { color: var(--text-muted); }

/* ── Funding Velocity ── */
.fvel-rising { color: var(--red); }
.fvel-falling { color: var(--green); }
.fvel-flat { color: var(--text-muted); }

/* ── L/S Ratio ── */
.ls-long-heavy { color: var(--green); }
.ls-short-heavy { color: var(--red); }
.ls-neutral { color: var(--text-primary); }

/* ── Loading overlay ── */
.loading-overlay {
  position: absolute; inset: 0; background: rgba(10,14,19,0.92);
  display: flex; flex-direction: column; align-items: center;
  justify-content: center; gap: 12px; z-index: 50;
  font-family: var(--font-mono); color: var(--text-secondary); font-size: 13px;
}
.loading-overlay.hidden { display: none; }
.spinner {
  display: inline-block; width: 24px; height: 24px;
  border: 2px solid var(--border-color); border-top-color: var(--blue);
  border-radius: 50%; animation: spin 0.8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }

/* ── Empty state ── */
.empty-state {
  text-align: center; padding: 60px 20px; color: var(--text-muted); font-size: 13px;
}
.empty-state-hint {
  display: block; margin-top: 8px; font-size: 11px; color: var(--text-muted);
  opacity: 0.7;
}

/* ── Scrollbar ── */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-muted); }
::-webkit-scrollbar-corner { background: var(--bg-primary); }

/* ── Responsive ── */
@media (max-width: 1400px) {
  :root { --row-height: 28px; }
  table { font-size: 11px; }
  thead th { padding: 5px 8px; font-size: 9px; }
  tbody td { padding: 0 8px; font-size: 11px; }
}
@media (max-width: 1024px) {
  .header { padding: 8px 12px; gap: 8px; }
  .search-box { flex: 0 0 140px; }
  .filter-bar {
    overflow-x: auto; flex-wrap: nowrap; -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .filter-bar::-webkit-scrollbar { display: none; }
  .brand-sub { display: none; }
}
@media (max-width: 768px) {
  :root { --row-height: 26px; }
  .header { flex-wrap: wrap; }
  .header-divider { display: none; }
  .search-box { flex: 1 1 100%; order: 10; }
  table { font-size: 10px; }
  thead th { padding: 4px 6px; font-size: 8px; letter-spacing: 0.3px; }
  tbody td { padding: 0 6px; font-size: 10px; }
  .filter-pill { padding: 3px 7px; font-size: 10px; }
  .status-bar { padding: 3px 10px; gap: 10px; font-size: 10px; }
}
</style>
</head>
<body>

<div class="refresh-stripe" id="refreshStripe">
  <div class="stripe-bar" id="stripeBar"></div>
</div>

<div class="app-layout">
  <div class="header">
    <div class="brand">
      <svg class="brand-icon" viewBox="0 0 24 24" width="22" height="22" fill="none">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1.5" opacity="0.2"/>
        <circle cx="12" cy="12" r="6" stroke="currentColor" stroke-width="1.5" opacity="0.4"/>
        <circle cx="12" cy="12" r="2.5" fill="var(--blue)"/>
        <line x1="12" y1="12" x2="19" y2="5" stroke="var(--green)" stroke-width="2" stroke-linecap="round"/>
      </svg>
      <div>
        <span class="brand-name"><span>Mello</span>Scan</span>
        <span class="brand-sub">Bybit Futures</span>
      </div>
    </div>
    <div class="header-divider"></div>
    <div class="search-box">
      <input type="text" id="searchInput" placeholder="Search symbol..." spellcheck="false" />
    </div>
    <div class="header-divider"></div>
    <div class="filter-bar">
      <button class="filter-pill" data-filter="oversold">RSI &le; 30</button>
      <button class="filter-pill" data-filter="overbought">RSI &ge; 70</button>
      <button class="filter-pill" data-filter="divergence">Divergence</button>
      <span class="filter-sep"></span>
      <button class="filter-pill" data-filter="squeeze">Squeeze</button>
      <button class="filter-pill" data-filter="oi-buildup">OI Buildup</button>
      <button class="filter-pill" data-filter="cvd-div">CVD Div</button>
      <button class="filter-pill" data-filter="rvol">RVol &gt; 2x</button>
      <button class="filter-pill" data-filter="choch-aligned">CHOCH Aligned</button>
      <span class="filter-sep"></span>
      <button class="filter-pill" data-filter="strong-long">Strong Long</button>
      <button class="filter-pill" data-filter="strong-short">Strong Short</button>
      <span class="filter-sep"></span>
      <button class="filter-pill" data-filter="grade-a">A Grade</button>
      <button class="filter-pill" data-filter="grade-b">B+ Grade</button>
      <button class="filter-clear" id="filterClear">Clear all</button>
      <span class="filter-result-count" id="filterResultCount"></span>
    </div>
    <div class="col-picker-wrapper">
      <button class="col-picker-btn" id="colPickerBtn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 3v18M3 12h18M5.5 5.5l13 13M18.5 5.5l-13 13"/></svg>
        Columns
      </button>
      <div class="col-picker-dropdown" id="colPickerDropdown">
        <div class="picker-header">Toggle &amp; reorder columns</div>
      </div>
    </div>
  </div>
  <div class="status-bar">
    <div class="status-item">
      <div class="status-dot" id="statusDot"></div>
      <span id="statusText">Initializing...</span>
    </div>
    <span class="status-separator">&middot;</span>
    <div class="status-item"><span id="instrumentCount">0</span> instruments</div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Updated <span id="lastRefresh">&mdash;</span></div>
    <span class="status-separator">&middot;</span>
    <div class="status-item">Indicators <span id="nextRefresh">&mdash;</span></div>
    <div class="status-item" id="dataProgress" style="display:none">
      <span class="status-separator">&middot;</span>
      <span id="dataProgressText"></span>
    </div>
  </div>
  <div class="table-container" id="tableContainer">
    <div class="loading-overlay" id="loadingOverlay">
      <div class="spinner"></div>
      Loading market data...
    </div>
    <table id="mainTable">
      <thead><tr id="headerRow"></tr></thead>
      <tbody id="tableBody"></tbody>
    </table>
  </div>
</div>

<script>
// ============================================================
// MelloScan — Bybit USDT Perpetual Screener
// ============================================================

const BYBIT_BASE = 'https://api.bybit.com';
const REFRESH_INTERVAL = 60000;
const BATCH_SIZE = 3;
const BATCH_DELAY = 250;
const RSI_PERIOD = 14;
const KLINE_LIMIT = 200;
const DAILY_KLINE_LIMIT = 50;
const DIV_LOOKBACK = 24;
const CACHE_KEY = 'melloscan_cache';
const CACHE_TS_KEY = 'melloscan_cache_ts';
const COL_PREFS_KEY = 'melloscan_columns';
const COL_ORDER_KEY = 'melloscan_col_order';
const BB_PERIOD = 20;
const BB_STD = 2;
const OI_HISTORY_LIMIT = 48;
const FUNDING_HISTORY_LIMIT = 10;

// ── WebSocket real-time feed ──
const WS_URL = 'wss://stream.bybit.com/v5/public/linear';
const WS_PING_INTERVAL = 20000;
const WS_RECONNECT_BASE_MS = 1000;
const WS_RECONNECT_MAX_MS = 30000;
const WS_SUB_BATCH = 10;
const KLINE_POLL_INTERVAL = 180000;   // 3 min — refresh RSI/divergence/CHOCH/CVD/squeeze
const OI_POLL_INTERVAL = 300000;      // 5 min — refresh OI delta, funding velocity, L/S ratio
const RENDER_THROTTLE_MS = 200;       // batch WS updates into renders

// ── Column definitions ──
const DEFAULT_COLUMNS = [
  { key: 'symbol',        label: 'Symbol',      align: 'left',  locked: true },
  { key: 'price',         label: 'Price',       align: 'right', locked: false },
  { key: 'change24h',     label: '24H Chg%',    align: 'right', locked: false },
  { key: 'volume24h',     label: '24H Vol',     align: 'right', locked: false },
  { key: 'relVolume',     label: 'Rel Vol',     align: 'right', locked: false },
  { key: 'rsiLtf',        label: 'RSI 15/30m',  align: 'right', locked: false },
  { key: 'rsiHtf',        label: 'RSI HTF',     align: 'right', locked: false },
  { key: 'signal',        label: 'Signal',      align: 'right', locked: false },
  { key: 'setupGrade',    label: 'Grade',       align: 'right', locked: false },
  { key: 'oiDelta',       label: 'OI Delta',    align: 'right', locked: false },
  { key: 'rangePosition', label: '24h Range',   align: 'right', locked: false },
  { key: 'cvd',           label: 'CVD',         align: 'right', locked: false },
  { key: 'squeeze',       label: 'Squeeze',     align: 'right', locked: false },
  { key: 'fundVelocity',  label: 'Fund Vel',    align: 'right', locked: false },
  { key: 'lsRatio',       label: 'L/S Ratio',   align: 'right', locked: false },
  { key: 'fundingRate',   label: 'Funding',     align: 'right', locked: false },
  { key: 'openInterest',  label: 'OI',          align: 'right', locked: false },
];

const COLUMN_MAP = {};
DEFAULT_COLUMNS.forEach(c => { COLUMN_MAP[c.key] = c; });

// P1: Default to 9 visible columns for new users
const DEFAULT_VISIBLE_KEYS = new Set([
  'symbol', 'price', 'change24h', 'volume24h', 'signal', 'setupGrade',
  'oiDelta', 'cvd', 'squeeze', 'fundingRate'
]);

let columnOrder = DEFAULT_COLUMNS.map(c => c.key);
let visibleColumns = new Set(DEFAULT_VISIBLE_KEYS);

function getAllColumnsOrdered() {
  return columnOrder.map(k => COLUMN_MAP[k]).filter(Boolean);
}
function getVisibleColumns() {
  return columnOrder.filter(k => visibleColumns.has(k)).map(k => COLUMN_MAP[k]);
}

function loadColumnPrefs() {
  try {
    const saved = localStorage.getItem(COL_PREFS_KEY);
    if (saved) {
      const arr = JSON.parse(saved);
      if (Array.isArray(arr) && arr.length > 0) {
        visibleColumns = new Set(arr);
        visibleColumns.add('symbol');
      }
    }
  } catch (e) { /* ignore */ }
  try {
    const savedOrder = localStorage.getItem(COL_ORDER_KEY);
    if (savedOrder) {
      const arr = JSON.parse(savedOrder);
      if (Array.isArray(arr) && arr.length > 0) {
        const validKeys = new Set(DEFAULT_COLUMNS.map(c => c.key));
        const ordered = arr.filter(k => validKeys.has(k));
        DEFAULT_COLUMNS.forEach(c => {
          if (!ordered.includes(c.key)) ordered.push(c.key);
        });
        const symIdx = ordered.indexOf('symbol');
        if (symIdx > 0) { ordered.splice(symIdx, 1); ordered.unshift('symbol'); }
        columnOrder = ordered;
      }
    }
  } catch (e) { /* ignore */ }
}

function saveColumnPrefs() {
  try {
    localStorage.setItem(COL_PREFS_KEY, JSON.stringify([...visibleColumns]));
    localStorage.setItem(COL_ORDER_KEY, JSON.stringify(columnOrder));
  } catch (e) { /* ignore */ }
}

// ── State ──
let instruments = {};
let sortLevels = [{ key: 'signal', dir: -1 }];
let activeFilters = new Set();
let searchText = '';
let refreshTimer = null;
let countdownTimer = null;
let nextRefreshAt = 0;
let isRefreshing = false;
let previousPrices = {};
let rsiAbortController = null;
let updateTimeouts = new Map(); // P3 fix: track row update timeouts

// WebSocket state
let wsConnection = null;
let wsReconnectAttempts = 0;
let wsPingTimer = null;
let wsConnected = false;
let wsFallbackTimer = null;
let dirtySymbols = new Set();
let renderThrottleTimer = null;
let klinePollTimer = null;
let oiPollTimer = null;

// ============================================================
// LocalStorage cache
// ============================================================

function saveCache() {
  try {
    localStorage.setItem(CACHE_KEY, JSON.stringify(instruments));
    localStorage.setItem(CACHE_TS_KEY, String(Date.now()));
  } catch (e) { console.warn('Cache save failed:', e.message); }
}

function loadCache() {
  try {
    const data = localStorage.getItem(CACHE_KEY);
    const ts = localStorage.getItem(CACHE_TS_KEY);
    if (!data || !ts) return false;
    const parsed = JSON.parse(data);
    if (!parsed || typeof parsed !== 'object' || Object.keys(parsed).length === 0) return false;
    instruments = parsed;
    const age = Date.now() - parseInt(ts, 10);
    const ageMin = Math.round(age / 60000);
    const ageStr = ageMin < 60 ? ageMin + 'm ago' : Math.round(ageMin / 60) + 'h ago';
    setStatus('Cached (' + ageStr + ')', true);
    updateInstrumentCount();
    renderTable();
    return true;
  } catch (e) {
    console.warn('Cache load failed:', e.message);
    return false;
  }
}

// ============================================================
// P0: Rate limiter + API with retry/backoff
// ============================================================

const rateLimiter = {
  timestamps: [],
  maxRequests: 80,  // Bybit limit: 120/5s — stay well under
  windowMs: 5000,
  async throttle() {
    const now = Date.now();
    this.timestamps = this.timestamps.filter(t => now - t < this.windowMs);
    if (this.timestamps.length >= this.maxRequests) {
      const oldest = this.timestamps[0];
      const waitMs = this.windowMs - (now - oldest) + 100;
      await new Promise(r => setTimeout(r, waitMs));
    }
    this.timestamps.push(Date.now());
  }
};

async function apiFetch(path, retries) {
  if (retries === undefined) retries = 3;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      await rateLimiter.throttle();
      const resp = await fetch(BYBIT_BASE + path);
      if (resp.status === 429) {
        const backoff = Math.pow(2, attempt) * 1000;
        console.warn('Rate limited on', path, '- backing off', backoff, 'ms');
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }
      if (!resp.ok) throw new Error('API ' + resp.status);
      const json = await resp.json();
      if (json.retCode !== 0) throw new Error('Bybit: ' + json.retMsg);
      return json.result;
    } catch (e) {
      if (attempt < retries && (e.name === 'TypeError' || e.message.includes('429'))) {
        const backoff = Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }
      throw e;
    }
  }
}

// ============================================================
// Data fetching
// ============================================================

async function fetchTickers() {
  const result = await apiFetch('/v5/market/tickers?category=linear');
  return (result.list || []).filter(t => t.symbol.endsWith('USDT'));
}

async function fetchKline(symbol, interval, limit) {
  const result = await apiFetch(
    '/v5/market/kline?category=linear&symbol=' + symbol +
    '&interval=' + interval + '&limit=' + limit
  );
  return (result.list || []).reverse();
}

async function fetchOIHistory(symbol) {
  const result = await apiFetch(
    '/v5/market/open-interest?category=linear&symbol=' + symbol +
    '&intervalTime=1h&limit=' + OI_HISTORY_LIMIT
  );
  return (result.list || []).reverse();
}

async function fetchFundingHistory(symbol) {
  const result = await apiFetch(
    '/v5/market/funding/history?category=linear&symbol=' + symbol +
    '&limit=' + FUNDING_HISTORY_LIMIT
  );
  return (result.list || []).reverse();
}

async function fetchAccountRatio(symbol) {
  const result = await apiFetch(
    '/v5/market/account-ratio?category=linear&symbol=' + symbol +
    '&period=1h&limit=1'
  );
  return result.list || [];
}

// ============================================================
// Technical calculations — existing
// ============================================================

function computeRSI(closes) {
  if (closes.length < RSI_PERIOD + 1) return null;
  var gains = 0, losses = 0;
  for (var i = 1; i <= RSI_PERIOD; i++) {
    var diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  var avgGain = gains / RSI_PERIOD;
  var avgLoss = losses / RSI_PERIOD;
  for (var i = RSI_PERIOD + 1; i < closes.length; i++) {
    var diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
  }
  if (avgLoss === 0) return 100;
  return 100 - 100 / (1 + avgGain / avgLoss);
}

function computeRSISeries(closes) {
  var rsiArr = new Array(closes.length).fill(null);
  if (closes.length < RSI_PERIOD + 1) return rsiArr;
  var gains = 0, losses = 0;
  for (var i = 1; i <= RSI_PERIOD; i++) {
    var diff = closes[i] - closes[i - 1];
    if (diff > 0) gains += diff; else losses -= diff;
  }
  var avgGain = gains / RSI_PERIOD;
  var avgLoss = losses / RSI_PERIOD;
  rsiArr[RSI_PERIOD] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  for (var i = RSI_PERIOD + 1; i < closes.length; i++) {
    var diff = closes[i] - closes[i - 1];
    avgGain = (avgGain * (RSI_PERIOD - 1) + (diff > 0 ? diff : 0)) / RSI_PERIOD;
    avgLoss = (avgLoss * (RSI_PERIOD - 1) + (diff < 0 ? -diff : 0)) / RSI_PERIOD;
    rsiArr[i] = avgLoss === 0 ? 100 : 100 - 100 / (1 + avgGain / avgLoss);
  }
  return rsiArr;
}

function detectDivergence(candles, rsiSeries) {
  var len = candles.length;
  if (len < 5) return 'none';
  var lookStart = Math.max(1, len - DIV_LOOKBACK);
  var lookEnd = len - 2;
  var swingLows = [], swingHighs = [];
  for (var i = lookStart; i <= lookEnd; i++) {
    if (rsiSeries[i] === null) continue;
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low, rsi: rsiSeries[i] });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high, rsi: rsiSeries[i] });
  }
  if (swingLows.length >= 2) {
    var recent = swingLows[swingLows.length - 1], prev = swingLows[swingLows.length - 2];
    if (recent.price < prev.price && recent.rsi > prev.rsi) return 'bull';
  }
  if (swingHighs.length >= 2) {
    var recent = swingHighs[swingHighs.length - 1], prev = swingHighs[swingHighs.length - 2];
    if (recent.price > prev.price && recent.rsi < prev.rsi) return 'bear';
  }
  return 'none';
}

function detectCHOCH(candles) {
  var len = candles.length;
  if (len < 10) return 'none';
  var swingHighs = [], swingLows = [];
  var lookStart = Math.max(1, len - 60);
  for (var i = lookStart; i < len - 1; i++) {
    if (candles[i].low < candles[i - 1].low && candles[i].low < candles[i + 1].low)
      swingLows.push({ idx: i, price: candles[i].low });
    if (candles[i].high > candles[i - 1].high && candles[i].high > candles[i + 1].high)
      swingHighs.push({ idx: i, price: candles[i].high });
  }
  if (swingHighs.length < 2 || swingLows.length < 2) return 'none';
  var recentSH = swingHighs.slice(-3), recentSL = swingLows.slice(-3);
  var isDowntrend = false;
  for (var i = recentSH.length - 1; i >= 1; i--) {
    if (recentSH[i].price < recentSH[i - 1].price) { isDowntrend = true; break; }
  }
  if (isDowntrend) {
    var lastSH = recentSH[recentSH.length - 1];
    var rw = Math.min(5, len - lastSH.idx);
    for (var j = len - rw; j < len; j++) {
      if (candles[j].close > lastSH.price) return 'bull';
    }
  }
  var isUptrend = false;
  for (var i = recentSL.length - 1; i >= 1; i--) {
    if (recentSL[i].price > recentSL[i - 1].price) { isUptrend = true; break; }
  }
  if (isUptrend) {
    var lastSL = recentSL[recentSL.length - 1];
    var rw = Math.min(5, len - lastSL.idx);
    for (var j = len - rw; j < len; j++) {
      if (candles[j].close < lastSL.price) return 'bear';
    }
  }
  return 'none';
}

// ============================================================
// Technical calculations — 5 composite features
// ============================================================

// ── 1. OI Delta vs Price ──
function computeOIDelta(oiHistory) {
  if (!oiHistory || oiHistory.length < 2) return { pct24h: null, pct4h: null };
  var newest = parseFloat(oiHistory[oiHistory.length - 1].openInterest);
  var oldest = parseFloat(oiHistory[0].openInterest);
  if (oldest === 0 || isNaN(oldest) || isNaN(newest)) return { pct24h: null, pct4h: null };
  var pct24h = ((newest - oldest) / oldest) * 100;
  var idx4h = Math.max(0, oiHistory.length - 5);
  var oi4hAgo = parseFloat(oiHistory[idx4h].openInterest);
  var pct4h = oi4hAgo > 0 ? ((newest - oi4hAgo) / oi4hAgo) * 100 : null;
  return { pct24h: pct24h, pct4h: pct4h };
}

// P1: OI delta label with relative thresholds
function getOIDeltaLabel(oiPct, priceChg, change24h) {
  if (oiPct === null) return { label: '\u2014', cls: 'oi-flat', dir: 0 };
  // Relative threshold: OI change must be at least 50% of price change magnitude, min 0.5%
  var threshold = Math.max(0.5, Math.abs(change24h || 0) * 0.5);
  var oiUp = oiPct > threshold;
  var oiDown = oiPct < -threshold;
  var priceUp = priceChg > 0;
  if (oiUp && priceUp) return { label: 'NEW LONG', cls: 'oi-new-long', dir: 1 };
  if (oiUp && !priceUp) return { label: 'NEW SHRT', cls: 'oi-new-short', dir: -1 };
  if (oiDown && priceUp) return { label: 'SHT CVR', cls: 'oi-short-cover', dir: -0.5 };
  if (oiDown && !priceUp) return { label: 'LIQ LNG', cls: 'oi-liq-long', dir: 0.5 };
  return { label: 'FLAT', cls: 'oi-flat', dir: 0 };
}

// ── 2. P0: 24h Range Position (replaces Liquidation Proximity) ──
function computePricePosition(price, high24h, low24h) {
  if (!price || !high24h || !low24h || high24h <= low24h) {
    return { abovePct: null, belowPct: null, position: null };
  }
  var range = high24h - low24h;
  var abovePct = ((high24h - price) / price) * 100;
  var belowPct = ((price - low24h) / price) * 100;
  var position = (price - low24h) / range; // 0 = at 24h low, 1 = at 24h high
  return { abovePct: abovePct, belowPct: belowPct, position: position };
}

// ── 3. Volume Delta / CVD ──
function computeCVD(candles) {
  if (!candles || candles.length < 5) return { trend: 'neutral', divergence: 'none', value: 0 };
  var cvd = 0, cvdSeries = [], priceSeries = [];
  for (var ci = 0; ci < candles.length; ci++) {
    var c = candles[ci];
    var range = c.high - c.low;
    if (range === 0) { cvdSeries.push(cvd); priceSeries.push(c.close); continue; }
    var buyRatio = (c.close - c.low) / range;
    var vol = c.volume || 0;
    cvd += vol * (2 * buyRatio - 1);
    cvdSeries.push(cvd);
    priceSeries.push(c.close);
  }
  var lookback = Math.min(10, cvdSeries.length);
  var recentCVD = cvdSeries.slice(-lookback);
  var cvdChange = recentCVD[recentCVD.length - 1] - recentCVD[0];
  var trend = cvdChange > 0 ? 'bull' : cvdChange < 0 ? 'bear' : 'neutral';
  var divergence = 'none';
  if (priceSeries.length >= 10) {
    var recentPrice = priceSeries.slice(-lookback);
    var priceChange = recentPrice[recentPrice.length - 1] - recentPrice[0];
    if (priceChange < 0 && cvdChange > 0) divergence = 'bull';
    else if (priceChange > 0 && cvdChange < 0) divergence = 'bear';
  }
  return { trend: trend, divergence: divergence, value: cvd };
}

// ── 4. Volatility Squeeze + OI (FIX: indexOf bias) ──
function computeSqueeze(closes) {
  if (!closes || closes.length < BB_PERIOD + 20) return { active: false, building: false, pctile: null };
  var widths = [];
  for (var i = BB_PERIOD; i <= closes.length; i++) {
    var slice = closes.slice(i - BB_PERIOD, i);
    var sma = slice.reduce(function(a, b) { return a + b; }, 0) / BB_PERIOD;
    if (sma === 0) { widths.push(0); continue; }
    var variance = slice.reduce(function(sum, val) { return sum + (val - sma) * (val - sma); }, 0) / BB_PERIOD;
    widths.push((2 * BB_STD * Math.sqrt(variance)) / sma);
  }
  if (widths.length < 2) return { active: false, building: false, pctile: null };
  var currentWidth = widths[widths.length - 1];
  var lookback = Math.min(20, widths.length);
  var recentWidths = widths.slice(-lookback);
  // FIX: Use count-based percentile instead of indexOf (avoids duplicate bias)
  var belowCount = recentWidths.filter(function(w) { return w < currentWidth; }).length;
  var pctile = belowCount / (recentWidths.length - 1);
  return { active: pctile <= 0.25, building: pctile > 0.25 && pctile <= 0.40, pctile: pctile };
}

// ── 5. Funding Velocity ──
function computeFundingVelocity(fundingHistory) {
  if (!fundingHistory || fundingHistory.length < 3) return { slope: null, dir: 'flat', current: null, avg: null };
  var rates = fundingHistory.map(function(f) { return parseFloat(f.fundingRate); }).filter(function(r) { return !isNaN(r); });
  if (rates.length < 3) return { slope: null, dir: 'flat', current: null, avg: null };
  var n = rates.length, sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  for (var i = 0; i < n; i++) {
    sumX += i; sumY += rates[i]; sumXY += i * rates[i]; sumX2 += i * i;
  }
  var denom = n * sumX2 - sumX * sumX;
  var slope = denom !== 0 ? (n * sumXY - sumX * sumY) / denom : 0;
  var avg = sumY / n;
  var threshold = 0.00002;
  var dir = slope > threshold ? 'rising' : slope < -threshold ? 'falling' : 'flat';
  return { slope: slope, dir: dir, current: rates[rates.length - 1], avg: avg };
}

// ============================================================
// Number formatting
// ============================================================

function formatPrice(p) {
  var n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  if (n >= 1000) return n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  if (n >= 1) return n.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
  var s = n.toFixed(8), parts = s.split('.'), dec = parts[1];
  while (dec.length > 4 && dec.endsWith('0')) dec = dec.slice(0, -1);
  return parts[0] + '.' + dec;
}

function formatVolume(v) {
  var n = parseFloat(v);
  if (isNaN(n)) return '\u2014';
  if (n >= 1e9) return (n / 1e9).toFixed(2) + 'B';
  if (n >= 1e6) return (n / 1e6).toFixed(2) + 'M';
  if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K';
  return n.toFixed(0);
}

function formatPct(p) {
  var n = parseFloat(p);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + n.toFixed(2) + '%';
}

function formatFundingRate(r) {
  var n = parseFloat(r);
  if (isNaN(n)) return '\u2014';
  return (n >= 0 ? '+' : '') + (n * 100).toFixed(4) + '%';
}

// ============================================================
// Cell class helpers
// ============================================================

function rsiClass(v) {
  if (v === null || v === undefined) return 'rsi-neutral';
  if (v <= 30) return 'rsi-oversold';
  if (v <= 40) return 'rsi-low';
  if (v <= 60) return 'rsi-neutral';
  if (v <= 70) return 'rsi-high';
  return 'rsi-overbought';
}

function rvolClass(v) {
  if (v === null || v === undefined) return 'rvol-normal';
  if (v > 1.5) return 'rvol-high';
  if (v >= 1.2) return 'rvol-medium';
  return 'rvol-normal';
}

function changeHeatClass(v) {
  var n = parseFloat(v);
  if (isNaN(n)) return '';
  var abs = Math.abs(n);
  if (n > 0) {
    if (abs >= 8) return 'cell-heat-green-3';
    if (abs >= 3) return 'cell-heat-green-2';
    if (abs >= 1) return 'cell-heat-green-1';
  } else if (n < 0) {
    if (abs >= 8) return 'cell-heat-red-3';
    if (abs >= 3) return 'cell-heat-red-2';
    if (abs >= 1) return 'cell-heat-red-1';
  }
  return '';
}

function rangePositionClass(position) {
  if (position === null || position === undefined) return 'range-mid';
  if (position >= 0.9) return 'range-at-high';
  if (position >= 0.7) return 'range-upper';
  if (position <= 0.1) return 'range-at-low';
  if (position <= 0.3) return 'range-lower';
  return 'range-mid';
}

// ============================================================
// Condensed column helpers
// ============================================================

function getMostExtremeRSI_HTF(d) {
  var rsis = [
    { val: d.rsi4h, tf: '4H' },
    { val: d.rsiDaily, tf: 'D' },
  ].filter(function(r) { return r.val !== null && r.val !== undefined; });
  if (rsis.length === 0) return { val: null, tf: '' };
  rsis.sort(function(a, b) { return Math.abs(b.val - 50) - Math.abs(a.val - 50); });
  return rsis[0];
}

function getChochSummary(d) {
  var chochs = [
    { val: d.choch15m, tf: '15m' }, { val: d.choch30m, tf: '30m' },
    { val: d.choch4h, tf: '4H' }, { val: d.chochDaily, tf: 'D' },
  ];
  var active = chochs.filter(function(c) { return c.val !== 'none' && c.val !== undefined; });
  if (active.length === 0) return { dir: 'none', count: 0, aligned: false };
  var bulls = active.filter(function(c) { return c.val === 'bull'; }).length;
  var bears = active.filter(function(c) { return c.val === 'bear'; }).length;
  var dir = bulls > bears ? 'bull' : bears > bulls ? 'bear' : 'mixed';
  var aligned = active.length >= 2 && active.every(function(c) { return c.val === active[0].val; });
  return { dir: dir, count: active.length, aligned: aligned };
}

// ============================================================
// Composite signal scoring — FIXED weighted system
// ============================================================
// P0: Range Position at 5% (was Liq Prox at 20%)
// P1: Squeeze multiplier moved to END
// P1: OI Delta uses relative thresholds
// P2: L/S Ratio added at 5%
// Weights: OI 25%, CVD 20%, Squeeze 15% (mult), FundVel 10%,
//          RSI+Div 15%, Range 5%, L/S 5%, CHOCH 5%
// ============================================================

function computeSignal(d) {
  var score = 0;

  // ── 1. OI Delta vs Price (25%, max ±5 pts) ──
  if (d.oiDeltaPct !== null && d.oiDeltaPct !== undefined) {
    // P1: Relative threshold — normalize OI change by price volatility
    var priceVol = Math.max(Math.abs(d.change24h || 0), 1);
    var oiSignificance = Math.abs(d.oiDeltaPct) / priceVol;
    var priceUp = d.change24h > 0;
    var relThreshold = 0.5; // OI must move at least 50% as much as price
    if (oiSignificance > relThreshold) {
      var strength = Math.min(oiSignificance / 3, 5);
      var oiUp = d.oiDeltaPct > 0;
      if (oiUp && priceUp) score += strength;         // New longs → bullish
      else if (oiUp && !priceUp) score -= strength;    // New shorts → bearish
      else if (!oiUp && priceUp) score -= strength * 0.4;  // Short covering → weak
      else if (!oiUp && !priceUp) score += strength * 0.6; // Liquidation → contrarian
    }
  }

  // ── 2. CVD Divergence (20%, max ±4 pts) ──
  if (d.cvdDivergence === 'bull') score += 3;
  else if (d.cvdDivergence === 'bear') score -= 3;
  if (d.cvdTrend === 'bull') score += 1;
  else if (d.cvdTrend === 'bear') score -= 1;

  // ── 3. Funding Velocity (10%, max ±2 pts, contrarian) ──
  if (d.fundVelDir === 'rising') {
    score -= Math.min(Math.abs(d.fundVelSlope || 0) / 0.00015, 2);
  } else if (d.fundVelDir === 'falling') {
    score += Math.min(Math.abs(d.fundVelSlope || 0) / 0.00015, 2);
  }

  // ── 4. RSI + Divergence (15%, max ±3.5 pts) ──
  var rsiEntries = [
    { val: d.rsi15m, w: 0.3 }, { val: d.rsi30m, w: 0.3 },
    { val: d.rsi4h, w: 0.7 }, { val: d.rsiDaily, w: 1.2 },
  ];
  for (var ri = 0; ri < rsiEntries.length; ri++) {
    var r = rsiEntries[ri];
    if (r.val === null || r.val === undefined) continue;
    if (r.val <= 20) score += 0.5 * r.w;
    else if (r.val <= 30) score += 0.3 * r.w;
    else if (r.val >= 80) score -= 0.5 * r.w;
    else if (r.val >= 70) score -= 0.3 * r.w;
  }
  if (d.div15m === 'bull' || d.div30m === 'bull') score += 1;
  if (d.div15m === 'bear' || d.div30m === 'bear') score -= 1;

  // ── 5. 24h Range Position (5%, max ±1 pt, mean-reversion) ──
  if (d.rangePosition !== null && d.rangePosition !== undefined) {
    // Near 24h high → slight short bias; near 24h low → slight long bias
    score += (0.5 - d.rangePosition) * 2; // ±1 max
  }

  // ── 6. L/S Ratio (5%, max ±1.5 pts, contrarian) ──
  if (d.lsRatio !== null && d.lsRatio !== undefined) {
    // lsRatio = buyRatio (0..1). Crowd is usually wrong at extremes.
    if (d.lsRatio > 0.6) score -= Math.min((d.lsRatio - 0.5) * 3, 1.5);
    else if (d.lsRatio < 0.4) score += Math.min((0.5 - d.lsRatio) * 3, 1.5);
  }

  // ── 7. CHOCH (5%, max ±2 pts) ──
  var ch = getChochSummary(d);
  if (ch.aligned && ch.count >= 2) {
    score += (ch.dir === 'bull' ? 2 : ch.dir === 'bear' ? -2 : 0);
  } else {
    var chochs = [d.choch15m, d.choch30m, d.choch4h, d.chochDaily];
    for (var ci = 0; ci < chochs.length; ci++) {
      if (chochs[ci] === 'bull') score += 0.3;
      else if (chochs[ci] === 'bear') score -= 0.3;
    }
  }

  // ── Funding rate extremes (contrarian) ──
  var fr = d.fundingRate;
  if (fr !== null && fr !== undefined && !isNaN(fr)) {
    if (fr <= -0.0005) score += 1;
    else if (fr >= 0.0005) score -= 1;
  }

  // ── P1 FIX: Volume amplifier THEN squeeze — applied LAST ──
  if (d.relVolume !== null && d.relVolume > 2) {
    score *= (d.relVolume > 3 ? 1.3 : 1.15);
  }

  // P1 FIX: Squeeze multiplier applied at the END (after all additive components)
  if (d.squeezeOn) {
    if (Math.abs(score) > 1) {
      score *= 1.35;
    }
    if (d.oiDeltaPct !== null && d.oiDeltaPct > 2) {
      score *= 1.15;
    }
  }

  return Math.round(score * 10) / 10;
}

function getSignalLabel(score) {
  var abs = Math.abs(score);
  if (abs < 4) return { label: 'NEUTRAL', cls: 'signal-neutral', badge: false };
  if (score >= 8) return { label: 'STR LONG', cls: 'signal-strong-long', badge: true };
  if (score >= 4) return { label: 'LONG', cls: 'signal-long', badge: false };
  if (score <= -8) return { label: 'STR SHORT', cls: 'signal-strong-short', badge: true };
  if (score <= -4) return { label: 'SHORT', cls: 'signal-short', badge: false };
  return { label: 'NEUTRAL', cls: 'signal-neutral', badge: false };
}

// ============================================================
// Setup Grade — 0-100 directional scoring (4 independent pillars)
// ============================================================
// Pillar weights: Trend 35, Squeeze/Momentum 30, Volume 20, RSI 15
// Each pillar measures an independent dimension to avoid multicollinearity.
// The grade is directional — it determines the BEST side (long or short)
// and scores how strong that setup is.
// ============================================================

function computeSetupGrade(d) {
  // --- Determine directional bias from existing signal ---
  var sig = d._signal || computeSignal(d);
  var isLong = sig >= 0;

  var trendPts = 0;    // max 35
  var sqzPts = 0;      // max 30
  var volPts = 0;      // max 20
  var rsiPts = 0;      // max 15

  // ── PILLAR 1: Trend Alignment (35 pts) ──
  // CHOCH multi-timeframe alignment is the primary trend signal
  var ch = getChochSummary(d);
  var chochDir = ch.dir; // 'bull', 'bear', 'mixed', 'none'
  var chochAligned = ch.aligned && ch.count >= 2;
  var trendMatchesBias = (isLong && chochDir === 'bull') || (!isLong && chochDir === 'bear');

  if (chochAligned && trendMatchesBias) {
    trendPts += 20; // Full alignment across timeframes in our direction
  } else if (chochAligned) {
    trendPts += 5;  // Aligned but counter to our direction — some structure
  } else if (trendMatchesBias && ch.count >= 1) {
    trendPts += 12; // Partial alignment
  }

  // CHOCH count bonus — more timeframes confirming = stronger
  if (trendMatchesBias) {
    var chochs = [d.choch15m, d.choch30m, d.choch4h, d.chochDaily];
    var matchDir = isLong ? 'bull' : 'bear';
    var matchCount = chochs.filter(function(c) { return c === matchDir; }).length;
    trendPts += Math.min(matchCount * 3, 10); // up to 10 for 3+ TFs
  }

  // 24H price change confirms direction (up to 5 pts)
  if (d.change24h !== null && d.change24h !== undefined) {
    var priceConfirms = (isLong && d.change24h > 0) || (!isLong && d.change24h < 0);
    if (priceConfirms) {
      trendPts += Math.min(Math.abs(d.change24h) / 2, 5);
    }
  }

  trendPts = Math.min(trendPts, 35);

  // ── PILLAR 2: Squeeze / Momentum (30 pts) ──
  // Squeeze state
  if (d.squeezeOn) {
    sqzPts += 15; // Active squeeze — volatility compressed, big move coming
  } else if (d.squeezeBuilding) {
    sqzPts += 7;  // Post-squeeze momentum building
  } else if (d.squeezePctile !== null && d.squeezePctile !== undefined) {
    // Near squeeze: lower percentile = closer to squeeze
    if (d.squeezePctile <= 0.50) sqzPts += 3;
  }

  // CVD confirms momentum direction (up to 10 pts)
  var cvdMatchesBias = (isLong && d.cvdTrend === 'bull') || (!isLong && d.cvdTrend === 'bear');
  var cvdDivMatchesBias = (isLong && d.cvdDivergence === 'bull') || (!isLong && d.cvdDivergence === 'bear');
  if (cvdDivMatchesBias) sqzPts += 7;  // CVD divergence in our direction — strong
  else if (cvdMatchesBias) sqzPts += 4; // CVD trend alignment

  // Funding velocity (contrarian, up to 5 pts)
  // Rising funding = longs crowded = bearish; falling = shorts crowded = bullish
  var fundConfirms = (isLong && d.fundVelDir === 'falling') || (!isLong && d.fundVelDir === 'rising');
  if (fundConfirms && d.fundVelSlope !== null) {
    sqzPts += Math.min(Math.abs(d.fundVelSlope) / 0.00008, 5);
  }

  sqzPts = Math.min(sqzPts, 30);

  // ── PILLAR 3: Volume / Participation (20 pts) ──
  // Relative volume — are real players involved?
  if (d.relVolume !== null && d.relVolume !== undefined) {
    if (d.relVolume >= 3.0) volPts += 10;       // Surge — 3x+ avg
    else if (d.relVolume >= 2.0) volPts += 7;    // Strong — 2x+ avg
    else if (d.relVolume >= 1.5) volPts += 5;    // Solid — above average
    else if (d.relVolume >= 1.0) volPts += 2;    // Average
  }

  // OI Delta confirms new money entering in our direction (up to 10 pts)
  if (d.oiDeltaPct !== null && d.oiDeltaPct !== undefined) {
    var oiUp = d.oiDeltaPct > 0;
    var priceUp = d.change24h > 0;
    var absOI = Math.abs(d.oiDeltaPct);
    // New longs with price up (long) or new shorts with price down (short)
    var oiConfirmsBias = (isLong && oiUp && priceUp) || (!isLong && oiUp && !priceUp);
    if (oiConfirmsBias) {
      volPts += Math.min(absOI / 1.5, 10);
    }
    // Contrarian: short liquidation (OI down, price up) is weak for longs
    // Give partial credit
    var contrarian = (isLong && !oiUp && priceUp) || (!isLong && !oiUp && !priceUp);
    if (contrarian) {
      volPts += Math.min(absOI / 4, 3);
    }
  }

  volPts = Math.min(volPts, 20);

  // ── PILLAR 4: RSI / Timing (15 pts) ──
  // RSI "sweet spot" — we want momentum but NOT exhaustion
  // For longs: best is 50-65 (trending, room to run). Penalize >75.
  // For shorts: best is 35-50. Penalize <25.
  var rsiVals = [
    { val: d.rsi4h, w: 2.5 },      // 4H most important
    { val: d.rsiDaily, w: 2.5 },    // Daily equally important
    { val: d.rsi15m, w: 1.0 },      // LTF fine-tuning
    { val: d.rsi30m, w: 1.0 },
  ];

  var rsiWeightSum = 0, rsiScoreSum = 0;
  for (var ri = 0; ri < rsiVals.length; ri++) {
    var rv = rsiVals[ri];
    if (rv.val === null || rv.val === undefined) continue;
    rsiWeightSum += rv.w;
    var rsiScore = 0;
    if (isLong) {
      // Long sweet spot: 50-65 = full, 40-50 or 65-75 = partial, <30 or >80 = poor
      if (rv.val >= 50 && rv.val <= 65) rsiScore = 1.0;
      else if (rv.val >= 40 && rv.val < 50) rsiScore = 0.6;
      else if (rv.val > 65 && rv.val <= 75) rsiScore = 0.5;
      else if (rv.val <= 30) rsiScore = 0.3; // Oversold — potential reversal, partial credit
      else if (rv.val > 75) rsiScore = 0.1;  // Overbought — risky entry
      else rsiScore = 0.2; // 30-40 range — weak
    } else {
      // Short sweet spot: 35-50 = full, 25-35 or 50-60 = partial, <20 or >70 = poor
      if (rv.val >= 35 && rv.val <= 50) rsiScore = 1.0;
      else if (rv.val > 50 && rv.val <= 60) rsiScore = 0.6;
      else if (rv.val >= 25 && rv.val < 35) rsiScore = 0.5;
      else if (rv.val >= 70) rsiScore = 0.3; // Overbought — potential reversal
      else if (rv.val < 25) rsiScore = 0.1;  // Oversold — risky short entry
      else rsiScore = 0.2; // 60-70 range — weak
    }
    rsiScoreSum += rsiScore * rv.w;
  }

  if (rsiWeightSum > 0) {
    rsiPts += (rsiScoreSum / rsiWeightSum) * 10; // up to 10 pts from sweet spot
  }

  // Divergence bonus (up to 5 pts) — divergence in our direction
  var divMatchesBias = (isLong && (d.div15m === 'bull' || d.div30m === 'bull')) ||
                       (!isLong && (d.div15m === 'bear' || d.div30m === 'bear'));
  if (divMatchesBias) {
    rsiPts += 5;
    // Double divergence (both 15m and 30m)
    var bothDiv = (isLong && d.div15m === 'bull' && d.div30m === 'bull') ||
                  (!isLong && d.div15m === 'bear' && d.div30m === 'bear');
    if (bothDiv) rsiPts += 2; // Can exceed 15 slightly, capped below
  }

  rsiPts = Math.min(rsiPts, 15);

  // ── Total & Grade ──
  var total = Math.round(trendPts + sqzPts + volPts + rsiPts);
  total = Math.max(0, Math.min(100, total));

  var grade, cls;
  if (total >= 80) { grade = 'A'; cls = 'grade-A'; }
  else if (total >= 60) { grade = 'B'; cls = 'grade-B'; }
  else if (total >= 40) { grade = 'C'; cls = 'grade-C'; }
  else if (total >= 20) { grade = 'D'; cls = 'grade-D'; }
  else { grade = 'F'; cls = 'grade-F'; }

  return {
    grade: grade,
    score: total,
    cls: cls,
    dir: isLong ? 'LONG' : 'SHORT',
    pillars: { trend: Math.round(trendPts), squeeze: Math.round(sqzPts), volume: Math.round(volPts), rsi: Math.round(rsiPts) }
  };
}

// P2: Update signal for a symbol (cached, only called on data change)
function updateSignalFor(symbol) {
  var d = instruments[symbol];
  if (d) {
    d._signal = computeSignal(d);
    d._grade = computeSetupGrade(d);
  }
}

// ============================================================
// P3: DOM cell builders (XSS hardening — no innerHTML for data)
// ============================================================

function buildRsiLtfCell(td, d) {
  function addRsi(container, val, div) {
    var span = document.createElement('span');
    if (val === null || val === undefined) {
      span.className = 'rsi-neutral'; span.textContent = '\u2014';
    } else {
      span.className = rsiClass(val); span.textContent = val.toFixed(1);
    }
    container.appendChild(span);
    if (div === 'bull' || div === 'bear') {
      var icon = document.createElement('span');
      icon.style.cssText = 'font-size:9px;margin-left:1px';
      icon.textContent = div === 'bull' ? '\u{1F7E2}' : '\u{1F534}';
      container.appendChild(icon);
    }
  }
  addRsi(td, d.rsi15m, d.div15m);
  var sep = document.createElement('span');
  sep.className = 'tf-label'; sep.textContent = '/';
  td.appendChild(sep);
  addRsi(td, d.rsi30m, d.div30m);
}

function buildRsiHtfCell(td, d) {
  var rsi = getMostExtremeRSI_HTF(d);
  if (rsi.val === null) {
    td.className = 'rsi-neutral'; td.textContent = '\u2014'; return;
  }
  var span = document.createElement('span');
  span.className = rsiClass(rsi.val); span.textContent = rsi.val.toFixed(1);
  td.appendChild(span);
  var tf = document.createElement('span');
  tf.className = 'tf-label'; tf.textContent = rsi.tf;
  td.appendChild(tf);
}

function buildSignalCell(td, score) {
  var sig = getSignalLabel(score);
  var span = document.createElement('span');
  span.className = sig.badge ? ('signal-badge ' + sig.cls) : sig.cls;
  span.textContent = sig.label;
  td.appendChild(span);
  if (sig.label !== 'NEUTRAL') {
    var sc = document.createElement('span');
    sc.className = 'signal-score';
    sc.textContent = (score > 0 ? '+' : '') + score;
    td.appendChild(sc);
  }
}

function buildGradeCell(td, d) {
  var g = d._grade;
  if (!g) { td.className = 'grade-F'; td.textContent = '\u2014'; return; }
  var badge = document.createElement('span');
  badge.className = (g.grade === 'A' || g.grade === 'B' || g.grade === 'C') ? ('grade-badge ' + g.cls) : g.cls;
  badge.textContent = g.grade;
  td.appendChild(badge);
  var dir = document.createElement('span');
  dir.className = 'grade-dir';
  dir.textContent = g.dir;
  td.appendChild(dir);
  var sc = document.createElement('span');
  sc.className = 'grade-score';
  sc.textContent = g.score;
  td.appendChild(sc);
  // Tooltip with pillar breakdown
  td.title = 'Trend: ' + g.pillars.trend + '/35  Squeeze: ' + g.pillars.squeeze + '/30  Volume: ' + g.pillars.volume + '/20  RSI: ' + g.pillars.rsi + '/15';
}

function buildOIDeltaCell(td, d) {
  if (d.oiDeltaPct === null || d.oiDeltaPct === undefined) {
    td.className = 'oi-flat'; td.textContent = '\u2014'; return;
  }
  var lbl = getOIDeltaLabel(d.oiDeltaPct, d.change24h, d.change24h);
  var main = document.createElement('span');
  main.className = lbl.cls; main.textContent = lbl.label;
  td.appendChild(main);
  var pct = document.createElement('span');
  pct.className = 'tf-label'; pct.style.marginLeft = '4px';
  pct.textContent = (d.oiDeltaPct >= 0 ? '+' : '') + d.oiDeltaPct.toFixed(1) + '%';
  td.appendChild(pct);
}

function buildRangePositionCell(td, d) {
  if (d.rangePosition === null || d.rangePosition === undefined) {
    td.className = 'range-mid'; td.textContent = '\u2014'; return;
  }
  td.className = rangePositionClass(d.rangePosition);
  var pct = Math.round(d.rangePosition * 100);
  var aboveStr = d.rangeAbovePct !== null ? d.rangeAbovePct.toFixed(1) + '%' : '';
  var belowStr = d.rangeBelowPct !== null ? d.rangeBelowPct.toFixed(1) + '%' : '';
  // Show position as percentage through range + distances
  var up = document.createElement('span');
  up.style.color = 'var(--red)'; up.textContent = '\u25B2' + aboveStr;
  td.appendChild(up);
  var sep = document.createElement('span');
  sep.className = 'tf-label'; sep.textContent = ' ' + pct + '% ';
  td.appendChild(sep);
  var dn = document.createElement('span');
  dn.style.color = 'var(--green)'; dn.textContent = '\u25BC' + belowStr;
  td.appendChild(dn);
}

function buildCvdCell(td, d) {
  if (d.cvdTrend === undefined && d.cvdDivergence === undefined) {
    td.className = 'cvd-neutral'; td.textContent = '\u2014'; return;
  }
  var cls = d.cvdTrend === 'bull' ? 'cvd-bull' : d.cvdTrend === 'bear' ? 'cvd-bear' : 'cvd-neutral';
  var icon = d.cvdTrend === 'bull' ? '\u25B2' : d.cvdTrend === 'bear' ? '\u25BC' : '\u25C6';
  var label = d.cvdTrend === 'bull' ? 'BUY' : d.cvdTrend === 'bear' ? 'SELL' : 'FLAT';
  var main = document.createElement('span');
  main.className = cls; main.textContent = icon + ' ' + label;
  td.appendChild(main);
  if (d.cvdDivergence === 'bull' || d.cvdDivergence === 'bear') {
    var div = document.createElement('span');
    div.style.cssText = 'font-size:9px;margin-left:3px;color:var(--' +
      (d.cvdDivergence === 'bull' ? 'green-bright' : 'red-bright') + ')';
    div.textContent = 'DIV' + (d.cvdDivergence === 'bull' ? '\u25B2' : '\u25BC');
    td.appendChild(div);
  }
}

function buildSqueezeCell(td, d) {
  if (d.squeezeOn === undefined || d.squeezePctile === null || d.squeezePctile === undefined) {
    td.className = 'squeeze-none'; td.textContent = '\u2014'; return;
  }
  if (d.squeezeOn) { td.className = 'squeeze-active'; td.textContent = 'SQUEEZE'; return; }
  if (d.squeezeBuilding) { td.className = 'squeeze-building'; td.textContent = 'BUILDING'; return; }
  td.className = 'squeeze-none';
  td.textContent = Math.round((1 - d.squeezePctile) * 100) + '%';
}

function buildFundVelCell(td, d) {
  if (!d.fundVelDir || d.fundVelSlope === null) {
    td.className = 'fvel-flat'; td.textContent = '\u2014'; return;
  }
  var cls = d.fundVelDir === 'rising' ? 'fvel-rising' : d.fundVelDir === 'falling' ? 'fvel-falling' : 'fvel-flat';
  var icon = d.fundVelDir === 'rising' ? '\u25B2' : d.fundVelDir === 'falling' ? '\u25BC' : '\u25C6';
  td.className = cls;
  var main = document.createElement('span');
  main.textContent = icon + ' ' + d.fundVelDir.toUpperCase();
  td.appendChild(main);
  var val = document.createElement('span');
  val.className = 'tf-label'; val.style.marginLeft = '3px';
  val.textContent = (d.fundVelSlope >= 0 ? '+' : '') + (d.fundVelSlope * 10000).toFixed(2);
  td.appendChild(val);
}

function buildLSRatioCell(td, d) {
  if (d.lsRatio === null || d.lsRatio === undefined) {
    td.className = 'ls-neutral'; td.textContent = '\u2014'; return;
  }
  var longPct = (d.lsRatio * 100).toFixed(0);
  var shortPct = ((1 - d.lsRatio) * 100).toFixed(0);
  td.className = d.lsRatio > 0.55 ? 'ls-long-heavy' : d.lsRatio < 0.45 ? 'ls-short-heavy' : 'ls-neutral';
  td.textContent = longPct + 'L/' + shortPct + 'S';
}

// ============================================================
// Table building
// ============================================================

var draggedColKey = null;

function buildHeader() {
  var tr = document.getElementById('headerRow');
  tr.innerHTML = '';
  getVisibleColumns().forEach(function(col) {
    var th = document.createElement('th');
    th.dataset.key = col.key;
    th.style.textAlign = col.align;
    var levelIdx = sortLevels.findIndex(function(s) { return s.key === col.key; });
    var isActive = levelIdx >= 0;
    var arrow = isActive ? (sortLevels[levelIdx].dir === 1 ? '\u25B2' : '\u25BC') : '\u25B2';
    var labelHTML = col.label;
    if (isActive && sortLevels.length > 1) {
      labelHTML += '<span class="sort-badge">' + (levelIdx + 1) + '</span>';
    }
    th.innerHTML = labelHTML + ' <span class="sort-arrow">' + arrow + '</span>';
    if (isActive) th.classList.add('sort-active');
    th.addEventListener('click', function(e) {
      if (th._wasDragged) { th._wasDragged = false; return; }
      onSort(col.key, e.shiftKey);
    });

    if (!col.locked) {
      th.draggable = true;
      th.addEventListener('dragstart', function(e) {
        draggedColKey = col.key;
        th.classList.add('col-dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', col.key);
      });
      th.addEventListener('dragend', function() {
        draggedColKey = null;
        th.classList.remove('col-dragging');
        tr.querySelectorAll('th').forEach(function(el) {
          el.classList.remove('col-drag-over-left', 'col-drag-over-right');
        });
      });
    }

    th.addEventListener('dragover', function(e) {
      if (!draggedColKey || draggedColKey === col.key || col.locked) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      var rect = th.getBoundingClientRect();
      var midX = rect.left + rect.width / 2;
      tr.querySelectorAll('th').forEach(function(el) {
        el.classList.remove('col-drag-over-left', 'col-drag-over-right');
      });
      if (e.clientX < midX) th.classList.add('col-drag-over-left');
      else th.classList.add('col-drag-over-right');
    });
    th.addEventListener('dragleave', function() {
      th.classList.remove('col-drag-over-left', 'col-drag-over-right');
    });
    th.addEventListener('drop', function(e) {
      e.preventDefault();
      if (!draggedColKey || draggedColKey === col.key || col.locked) return;
      var rect = th.getBoundingClientRect();
      var midX = rect.left + rect.width / 2;
      var dropBefore = e.clientX < midX;
      var fromIdx = columnOrder.indexOf(draggedColKey);
      columnOrder.splice(fromIdx, 1);
      var toIdx = columnOrder.indexOf(col.key);
      if (!dropBefore) toIdx += 1;
      columnOrder.splice(toIdx, 0, draggedColKey);
      saveColumnPrefs();
      var draggedTh = tr.querySelector('th[data-key="' + draggedColKey + '"]');
      if (draggedTh) draggedTh._wasDragged = true;
      buildHeader(); renderTable(); buildColumnPicker();
    });

    tr.appendChild(th);
  });
}

function onSort(key, addLevel) {
  if (addLevel) {
    var idx = sortLevels.findIndex(function(s) { return s.key === key; });
    if (idx >= 0) sortLevels[idx].dir *= -1;
    else sortLevels.push({ key: key, dir: -1 });
  } else {
    if (sortLevels.length === 1 && sortLevels[0].key === key) sortLevels[0].dir *= -1;
    else sortLevels = [{ key: key, dir: -1 }];
  }
  buildHeader(); renderTable();
}

function getSortedFiltered() {
  var arr = Object.values(instruments);

  if (searchText) {
    var q = searchText.toUpperCase();
    arr = arr.filter(function(d) { return d.symbol.includes(q); });
  }

  if (activeFilters.has('oversold')) {
    arr = arr.filter(function(d) {
      return (d.rsi15m !== null && d.rsi15m <= 30) || (d.rsi30m !== null && d.rsi30m <= 30) ||
        (d.rsi4h !== null && d.rsi4h <= 30) || (d.rsiDaily !== null && d.rsiDaily <= 30);
    });
  }
  if (activeFilters.has('overbought')) {
    arr = arr.filter(function(d) {
      return (d.rsi15m !== null && d.rsi15m >= 70) || (d.rsi30m !== null && d.rsi30m >= 70) ||
        (d.rsi4h !== null && d.rsi4h >= 70) || (d.rsiDaily !== null && d.rsiDaily >= 70);
    });
  }
  if (activeFilters.has('divergence')) {
    arr = arr.filter(function(d) {
      return d.div15m === 'bull' || d.div15m === 'bear' || d.div30m === 'bull' || d.div30m === 'bear';
    });
  }
  if (activeFilters.has('rvol')) {
    arr = arr.filter(function(d) { return d.relVolume !== null && d.relVolume > 2; });
  }
  if (activeFilters.has('choch-aligned')) {
    arr = arr.filter(function(d) {
      var vals = [d.choch15m, d.choch30m, d.choch4h, d.chochDaily].filter(function(v) { return v !== 'none'; });
      return vals.length >= 2 && vals.every(function(v) { return v === vals[0]; });
    });
  }
  if (activeFilters.has('squeeze')) {
    arr = arr.filter(function(d) { return d.squeezeOn === true; });
  }
  if (activeFilters.has('oi-buildup')) {
    arr = arr.filter(function(d) {
      return d.oiDeltaPct !== null && d.oiDeltaPct !== undefined && Math.abs(d.oiDeltaPct) > 5;
    });
  }
  if (activeFilters.has('cvd-div')) {
    arr = arr.filter(function(d) {
      return d.cvdDivergence === 'bull' || d.cvdDivergence === 'bear';
    });
  }

  // P2: Use cached signals (no recomputation on every render)
  if (activeFilters.has('strong-long')) {
    arr = arr.filter(function(d) { return (d._signal || 0) >= 8; });
  }
  if (activeFilters.has('strong-short')) {
    arr = arr.filter(function(d) { return (d._signal || 0) <= -8; });
  }
  if (activeFilters.has('grade-a')) {
    arr = arr.filter(function(d) { return d._grade && d._grade.score >= 80; });
  }
  if (activeFilters.has('grade-b')) {
    arr = arr.filter(function(d) { return d._grade && d._grade.score >= 60; });
  }

  function compareByKey(a, b, key, dir) {
    if (key === 'symbol') return dir * a.symbol.localeCompare(b.symbol);
    if (key === 'rsiLtf') {
      var ea = [a.rsi15m, a.rsi30m].filter(function(v) { return v !== null; });
      var eb = [b.rsi15m, b.rsi30m].filter(function(v) { return v !== null; });
      var va = ea.length > 0 ? Math.max.apply(null, ea.map(function(r) { return Math.abs(r - 50); })) : -1;
      var vb = eb.length > 0 ? Math.max.apply(null, eb.map(function(r) { return Math.abs(r - 50); })) : -1;
      return dir * (va - vb);
    }
    if (key === 'rsiHtf') {
      var ra = getMostExtremeRSI_HTF(a), rb = getMostExtremeRSI_HTF(b);
      return dir * ((ra.val !== null ? Math.abs(ra.val - 50) : -1) - (rb.val !== null ? Math.abs(rb.val - 50) : -1));
    }
    if (key === 'signal') {
      return dir * (Math.abs(a._signal || 0) - Math.abs(b._signal || 0));
    }
    if (key === 'setupGrade') {
      var ga = a._grade ? a._grade.score : -1;
      var gb = b._grade ? b._grade.score : -1;
      return dir * (ga - gb);
    }
    if (key === 'oiDelta') {
      var va = a.oiDeltaPct != null ? Math.abs(a.oiDeltaPct) : -1;
      var vb = b.oiDeltaPct != null ? Math.abs(b.oiDeltaPct) : -1;
      return dir * (va - vb);
    }
    if (key === 'rangePosition') {
      var va = a.rangePosition != null ? Math.abs(a.rangePosition - 0.5) : -1;
      var vb = b.rangePosition != null ? Math.abs(b.rangePosition - 0.5) : -1;
      return dir * (va - vb);
    }
    if (key === 'cvd') {
      var cvdScore = function(d) {
        var s = 0;
        if (d.cvdDivergence === 'bull' || d.cvdDivergence === 'bear') s += 2;
        if (d.cvdTrend === 'bull' || d.cvdTrend === 'bear') s += 1;
        return s;
      };
      return dir * (cvdScore(a) - cvdScore(b));
    }
    if (key === 'squeeze') {
      var sqScore = function(d) { return d.squeezeOn ? 2 : d.squeezeBuilding ? 1 : 0; };
      return dir * (sqScore(a) - sqScore(b));
    }
    if (key === 'fundVelocity') {
      var va = a.fundVelSlope != null ? Math.abs(a.fundVelSlope) : -1;
      var vb = b.fundVelSlope != null ? Math.abs(b.fundVelSlope) : -1;
      return dir * (va - vb);
    }
    if (key === 'lsRatio') {
      var va = a.lsRatio != null ? Math.abs(a.lsRatio - 0.5) : -1;
      var vb = b.lsRatio != null ? Math.abs(b.lsRatio - 0.5) : -1;
      return dir * (va - vb);
    }
    var va = a[key], vb = b[key];
    if (va == null) va = dir === 1 ? Infinity : -Infinity;
    if (vb == null) vb = dir === 1 ? Infinity : -Infinity;
    if (typeof va === 'string') va = parseFloat(va) || 0;
    if (typeof vb === 'string') vb = parseFloat(vb) || 0;
    return dir * (va - vb);
  }

  arr.sort(function(a, b) {
    for (var li = 0; li < sortLevels.length; li++) {
      var cmp = compareByKey(a, b, sortLevels[li].key, sortLevels[li].dir);
      if (cmp !== 0) return cmp;
    }
    return 0;
  });
  return arr;
}

function renderTable() {
  var tbody = document.getElementById('tableBody');
  var arr = getSortedFiltered();
  var cols = getVisibleColumns();
  var totalCount = Object.keys(instruments).length;

  var countEl = document.getElementById('filterResultCount');
  countEl.textContent = (activeFilters.size > 0 || searchText) ? arr.length + ' / ' + totalCount : '';

  // FIX: Clear pending update timeouts before rebuilding DOM
  updateTimeouts.forEach(function(id) { clearTimeout(id); });
  updateTimeouts.clear();

  if (arr.length === 0) {
    var hint = activeFilters.size > 0
      ? 'Try removing some filters to see more results.'
      : searchText ? 'No symbols match "' + searchText + '".' : '';
    tbody.innerHTML = '<tr><td colspan="' + cols.length + '" class="empty-state">' +
      'No instruments match the current filters' +
      (hint ? '<span class="empty-state-hint">' + hint + '</span>' : '') + '</td></tr>';
    return;
  }

  var frag = document.createDocumentFragment();
  for (var ai = 0; ai < arr.length; ai++) {
    var d = arr[ai];
    var tr = document.createElement('tr');
    tr.dataset.symbol = d.symbol;

    if (previousPrices[d.symbol] !== undefined && previousPrices[d.symbol] !== d.price) {
      tr.classList.add('updated');
      (function(row, sym) {
        var tid = setTimeout(function() { row.classList.remove('updated'); updateTimeouts.delete(sym); }, 2000);
        updateTimeouts.set(sym, tid);
      })(tr, d.symbol);
    }

    for (var ci = 0; ci < cols.length; ci++) {
      var col = cols[ci];
      var td = document.createElement('td');

      // P3: All data cells use textContent/DOM building — no innerHTML
      switch (col.key) {
        case 'symbol':     td.textContent = d.symbol; break;
        case 'price':      td.textContent = formatPrice(d.price); break;
        case 'change24h':
          td.textContent = formatPct(d.change24h);
          td.className = changeHeatClass(d.change24h) || (d.change24h >= 0 ? 'change-positive' : 'change-negative');
          break;
        case 'volume24h':  td.textContent = formatVolume(d.volume24h); break;
        case 'relVolume':
          td.textContent = d.relVolume !== null ? d.relVolume.toFixed(1) + 'x' : '\u2014';
          td.className = rvolClass(d.relVolume);
          break;
        case 'rsiLtf':        buildRsiLtfCell(td, d); break;
        case 'rsiHtf':         buildRsiHtfCell(td, d); break;
        case 'signal':         buildSignalCell(td, d._signal || 0); break;
        case 'setupGrade':     buildGradeCell(td, d); break;
        case 'oiDelta':        buildOIDeltaCell(td, d); break;
        case 'rangePosition':  buildRangePositionCell(td, d); break;
        case 'cvd':            buildCvdCell(td, d); break;
        case 'squeeze':        buildSqueezeCell(td, d); break;
        case 'fundVelocity':   buildFundVelCell(td, d); break;
        case 'lsRatio':        buildLSRatioCell(td, d); break;
        case 'fundingRate':
          td.textContent = formatFundingRate(d.fundingRate);
          var n = parseFloat(d.fundingRate);
          if (!isNaN(n) && n !== 0) {
            var intensity = Math.min(1, Math.abs(n) / 0.001);
            if (n < 0) td.style.color = 'rgb(50,' + Math.round(100 + 155 * intensity) + ',80)';
            else td.style.color = 'rgb(' + Math.round(150 + 105 * intensity) + ',70,70)';
          }
          break;
        case 'openInterest':   td.textContent = formatVolume(d.openInterest); break;
      }
      tr.appendChild(td);
    }
    frag.appendChild(tr);
  }
  tbody.innerHTML = '';
  tbody.appendChild(frag);
}

// ============================================================
// Status / refresh indicators
// ============================================================

function setStatus(text, loading) {
  document.getElementById('statusText').textContent = text;
  document.getElementById('statusDot').classList.toggle('loading', !!loading);
}
function updateInstrumentCount() {
  document.getElementById('instrumentCount').textContent = Object.keys(instruments).length;
}
function setRefreshStripe(pct) {
  var stripe = document.getElementById('refreshStripe');
  var bar = document.getElementById('stripeBar');
  if (pct < 0) { stripe.classList.remove('active', 'indeterminate'); bar.style.width = '0%'; return; }
  stripe.classList.add('active'); stripe.classList.remove('indeterminate');
  bar.style.width = pct + '%';
}
function setRefreshStripeIndeterminate(on) {
  var stripe = document.getElementById('refreshStripe');
  if (on) stripe.classList.add('active', 'indeterminate');
  else stripe.classList.remove('active', 'indeterminate');
}
function setDataProgress(done, total, phase) {
  var el = document.getElementById('dataProgress');
  var txt = document.getElementById('dataProgressText');
  if (done < 0) { el.style.display = 'none'; setRefreshStripe(-1); return; }
  el.style.display = '';
  txt.textContent = (phase || 'Data') + ' ' + done + '/' + total;
  setRefreshStripe(Math.round(done / total * 100));
}
function updateLastRefresh() {
  document.getElementById('lastRefresh').textContent =
    new Date().toLocaleTimeString('en-US', { hour12: false });
}
// startCountdown() replaced by startIndicatorCountdown() in WebSocket section

// ============================================================
// Main data loading
// ============================================================

async function loadTickers() {
  setStatus('Fetching tickers...', true);
  setRefreshStripeIndeterminate(true);
  var tickers = await fetchTickers();

  previousPrices = {};
  Object.values(instruments).forEach(function(d) { previousPrices[d.symbol] = d.price; });

  tickers.forEach(function(t) {
    var sym = t.symbol;
    var existing = instruments[sym] || {};
    var price = parseFloat(t.lastPrice) || 0;
    var high24h = parseFloat(t.highPrice24h) || 0;
    var low24h = parseFloat(t.lowPrice24h) || 0;

    // P0: Compute 24h range position from real ticker data
    var rp = computePricePosition(price, high24h, low24h);

    instruments[sym] = {
      symbol: sym,
      price: price,
      change24h: parseFloat(t.price24hPcnt) * 100 || 0,
      volume24h: parseFloat(t.turnover24h) || 0,
      fundingRate: parseFloat(t.fundingRate) || 0,
      openInterest: parseFloat(t.openInterest) * price,
      high24h: high24h,
      low24h: low24h,
      rangePosition: rp.position,
      rangeAbovePct: rp.abovePct,
      rangeBelowPct: rp.belowPct,
      relVolume: existing.relVolume || null,
      rsi15m: existing.rsi15m || null,
      rsi30m: existing.rsi30m || null,
      rsi4h: existing.rsi4h || null,
      rsiDaily: existing.rsiDaily || null,
      div15m: existing.div15m || 'none',
      div30m: existing.div30m || 'none',
      choch15m: existing.choch15m || 'none',
      choch30m: existing.choch30m || 'none',
      choch4h: existing.choch4h || 'none',
      chochDaily: existing.chochDaily || 'none',
      oiDeltaPct: existing.oiDeltaPct || null,
      oiDelta4h: existing.oiDelta4h || null,
      cvdTrend: existing.cvdTrend || 'neutral',
      cvdDivergence: existing.cvdDivergence || 'none',
      squeezeOn: existing.squeezeOn || false,
      squeezeBuilding: existing.squeezeBuilding || false,
      squeezePctile: existing.squeezePctile || null,
      fundVelSlope: existing.fundVelSlope || null,
      fundVelDir: existing.fundVelDir || 'flat',
      lsRatio: existing.lsRatio || null,
      _signal: existing._signal || 0,
    };
    updateSignalFor(sym);
  });

  var activeSyms = new Set(tickers.map(function(t) { return t.symbol; }));
  Object.keys(instruments).forEach(function(s) { if (!activeSyms.has(s)) delete instruments[s]; });

  updateInstrumentCount();
  setStatus('Tickers loaded', false);
  setRefreshStripeIndeterminate(false);
}

async function loadKlineDataForSymbol(symbol) {
  var intervals = [
    { key: '15', rsiKey: 'rsi15m', divKey: 'div15m', chochKey: 'choch15m' },
    { key: '30', rsiKey: 'rsi30m', divKey: 'div30m', chochKey: 'choch30m' },
    { key: '240', rsiKey: 'rsi4h', divKey: null, chochKey: 'choch4h' },
    { key: 'D', rsiKey: 'rsiDaily', divKey: null, chochKey: 'chochDaily' },
  ];
  var inst = instruments[symbol];
  if (!inst) return;

  for (var ivi = 0; ivi < intervals.length; ivi++) {
    var iv = intervals[ivi];
    try {
      // FIX: Use DAILY_KLINE_LIMIT for daily candles
      var limit = iv.key === 'D' ? DAILY_KLINE_LIMIT : KLINE_LIMIT;
      var candles = await fetchKline(symbol, iv.key, limit);
      if (!candles || candles.length < RSI_PERIOD + 2) {
        inst[iv.rsiKey] = null;
        if (iv.divKey) inst[iv.divKey] = 'none';
        inst[iv.chochKey] = 'none';
        continue;
      }
      var closes = candles.map(function(c) { return parseFloat(c[4]); });
      var highs = candles.map(function(c) { return parseFloat(c[2]); });
      var lows = candles.map(function(c) { return parseFloat(c[3]); });
      inst[iv.rsiKey] = computeRSI(closes);
      var candleObjs = candles.map(function(c, i) {
        return {
          high: highs[i], low: lows[i], close: closes[i],
          open: parseFloat(c[1]),
          volume: parseFloat(c[5]) || parseFloat(c[6]) || 0,
        };
      });
      if (iv.divKey) {
        inst[iv.divKey] = detectDivergence(candleObjs, computeRSISeries(closes));
      }
      inst[iv.chochKey] = detectCHOCH(candleObjs);

      // CVD from 4H candles
      if (iv.key === '240') {
        var cvdResult = computeCVD(candleObjs);
        inst.cvdTrend = cvdResult.trend;
        inst.cvdDivergence = cvdResult.divergence;
      }

      // Squeeze from Daily candles
      if (iv.key === 'D') {
        var sqResult = computeSqueeze(closes);
        inst.squeezeOn = sqResult.active;
        inst.squeezeBuilding = sqResult.building || false;
        inst.squeezePctile = sqResult.pctile;
      }

      // Relative volume from Daily turnover
      if (iv.key === 'D') {
        var turnovers = candles.map(function(c) { return parseFloat(c[6]); });
        if (turnovers.length >= 2) {
          var prevDays = turnovers.slice(-21, -1);
          if (prevDays.length > 0) {
            var avgVol = prevDays.reduce(function(a, b) { return a + b; }, 0) / prevDays.length;
            inst.relVolume = avgVol > 0 ? inst.volume24h / avgVol : null;
          }
        }
      }
    } catch (e) {
      console.warn('Kline failed:', symbol, iv.key, e.message);
    }
  }
  // P2: Update cached signal after kline data loads
  updateSignalFor(symbol);
}

async function loadAdditionalDataForSymbol(symbol) {
  var inst = instruments[symbol];
  if (!inst) return;

  // FIX: Removed redundant .catch() — Promise.allSettled already handles rejections
  var results = await Promise.allSettled([
    fetchOIHistory(symbol),
    fetchFundingHistory(symbol),
    fetchAccountRatio(symbol),
  ]);

  // OI Delta
  var oiHistory = results[0].status === 'fulfilled' ? results[0].value : null;
  if (oiHistory && oiHistory.length >= 2) {
    var oiDelta = computeOIDelta(oiHistory);
    inst.oiDeltaPct = oiDelta.pct24h;
    inst.oiDelta4h = oiDelta.pct4h;
  }

  // Funding Velocity
  var fundingHistory = results[1].status === 'fulfilled' ? results[1].value : null;
  if (fundingHistory && fundingHistory.length >= 3) {
    var fv = computeFundingVelocity(fundingHistory);
    inst.fundVelSlope = fv.slope;
    inst.fundVelDir = fv.dir;
  }

  // P2: L/S Ratio
  var ratioData = results[2].status === 'fulfilled' ? results[2].value : null;
  if (ratioData && ratioData.length > 0) {
    var buyRatio = parseFloat(ratioData[ratioData.length - 1].buyRatio);
    if (!isNaN(buyRatio)) inst.lsRatio = buyRatio;
  }

  // P2: Update cached signal after additional data loads
  updateSignalFor(symbol);
}

async function loadAllData(signal) {
  var symbols = Object.keys(instruments);
  var total = symbols.length;
  var done = 0;

  // Phase 1: Klines
  setDataProgress(0, total, 'Klines');
  for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
    if (signal && signal.aborted) return;
    var batch = symbols.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(function(sym) { return loadKlineDataForSymbol(sym); }));
    done += batch.length;
    setDataProgress(done, total, 'Klines');
    renderTable();
    if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
  }

  // Phase 2: OI + Funding + L/S Ratio
  done = 0;
  setDataProgress(0, total, 'OI+Fund+L/S');
  for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
    if (signal && signal.aborted) return;
    var batch = symbols.slice(i, i + BATCH_SIZE);
    await Promise.all(batch.map(function(sym) { return loadAdditionalDataForSymbol(sym); }));
    done += batch.length;
    setDataProgress(done, total, 'OI+Fund+L/S');
    renderTable();
    if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
  }

  setDataProgress(-1);
  saveCache();
}

async function fullRefresh() {
  if (isRefreshing) return;
  isRefreshing = true;
  try {
    if (rsiAbortController) rsiAbortController.abort();
    rsiAbortController = new AbortController();
    await loadTickers();
    renderTable();
    updateLastRefresh();
    await loadAllData(rsiAbortController.signal);
    if (!wsConnected) setStatus('Live', false);
  } catch (e) {
    setStatus('Error: ' + e.message, false);
    console.error('Refresh error:', e);
  } finally {
    isRefreshing = false;
    setRefreshStripe(-1);
  }
}

// ============================================================
// Column picker
// ============================================================

var pickerDragKey = null;

function buildColumnPicker() {
  var dropdown = document.getElementById('colPickerDropdown');
  var header = dropdown.querySelector('.picker-header');
  dropdown.innerHTML = '';
  dropdown.appendChild(header);

  getAllColumnsOrdered().forEach(function(col) {
    var item = document.createElement('label');
    item.className = 'col-picker-item' + (col.locked ? ' disabled' : '');
    item.dataset.key = col.key;

    var handle = document.createElement('span');
    handle.className = 'drag-handle'; handle.textContent = '\u2261';
    item.appendChild(handle);

    var cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = visibleColumns.has(col.key);
    if (col.locked) cb.disabled = true;
    cb.addEventListener('change', function() {
      if (col.locked) return;
      if (cb.checked) visibleColumns.add(col.key);
      else visibleColumns.delete(col.key);
      saveColumnPrefs(); buildHeader(); renderTable();
    });
    item.appendChild(cb);
    item.appendChild(document.createTextNode(col.label));

    if (!col.locked) {
      item.draggable = true;
      item.addEventListener('dragstart', function(e) {
        pickerDragKey = col.key;
        item.classList.add('picker-dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', col.key);
      });
      item.addEventListener('dragend', function() {
        pickerDragKey = null;
        item.classList.remove('picker-dragging');
        dropdown.querySelectorAll('.col-picker-item').forEach(function(el) {
          el.classList.remove('picker-drag-over');
        });
      });
    }
    item.addEventListener('dragover', function(e) {
      if (!pickerDragKey || pickerDragKey === col.key || col.locked) return;
      e.preventDefault(); e.dataTransfer.dropEffect = 'move';
      dropdown.querySelectorAll('.col-picker-item').forEach(function(el) {
        el.classList.remove('picker-drag-over');
      });
      item.classList.add('picker-drag-over');
    });
    item.addEventListener('dragleave', function() {
      item.classList.remove('picker-drag-over');
    });
    item.addEventListener('drop', function(e) {
      e.preventDefault();
      if (!pickerDragKey || pickerDragKey === col.key || col.locked) return;
      var fromIdx = columnOrder.indexOf(pickerDragKey);
      columnOrder.splice(fromIdx, 1);
      var toIdx = columnOrder.indexOf(col.key);
      columnOrder.splice(toIdx, 0, pickerDragKey);
      saveColumnPrefs(); buildColumnPicker(); buildHeader(); renderTable();
    });
    dropdown.appendChild(item);
  });
}

document.getElementById('colPickerBtn').addEventListener('click', function(e) {
  e.stopPropagation();
  document.getElementById('colPickerDropdown').classList.toggle('open');
});
document.addEventListener('click', function(e) {
  var dd = document.getElementById('colPickerDropdown');
  if (!dd.contains(e.target) && e.target !== document.getElementById('colPickerBtn')) {
    dd.classList.remove('open');
  }
});

// ============================================================
// Event handlers
// ============================================================

document.getElementById('searchInput').addEventListener('input', function(e) {
  searchText = e.target.value.trim();
  renderTable();
});

document.querySelectorAll('.filter-pill').forEach(function(btn) {
  btn.addEventListener('click', function() {
    var f = btn.dataset.filter;
    if (activeFilters.has(f)) { activeFilters.delete(f); btn.classList.remove('active'); }
    else { activeFilters.add(f); btn.classList.add('active'); }
    updateFilterClearBtn(); renderTable();
  });
});

document.getElementById('filterClear').addEventListener('click', function() {
  activeFilters.clear();
  document.querySelectorAll('.filter-pill').forEach(function(btn) { btn.classList.remove('active'); });
  updateFilterClearBtn(); renderTable();
});

function updateFilterClearBtn() {
  document.getElementById('filterClear').classList.toggle('visible', activeFilters.size > 0);
}

// ============================================================
// WebSocket real-time data feed
// ============================================================

function wsConnect() {
  if (wsConnection && wsConnection.readyState <= 1) return;
  try {
    wsConnection = new WebSocket(WS_URL);
  } catch (e) {
    console.error('WS connect error:', e);
    wsScheduleReconnect();
    return;
  }

  wsConnection.onopen = function() {
    wsConnected = true;
    wsReconnectAttempts = 0;
    setWsStatus('connected');
    wsStartPing();
    wsSubscribeAll();
    // Stop fallback REST polling if running
    if (wsFallbackTimer) { clearInterval(wsFallbackTimer); wsFallbackTimer = null; }
    updateLastRefresh();
  };

  wsConnection.onmessage = function(event) {
    try {
      var msg = JSON.parse(event.data);
      if (msg.op === 'pong' || msg.op === 'ping') return;
      if (msg.op === 'subscribe') {
        if (!msg.success) console.warn('WS sub failed:', msg.ret_msg);
        return;
      }
      if (msg.topic && msg.topic.startsWith('tickers.')) {
        processWsTicker(msg);
      }
    } catch (e) {
      console.warn('WS message error:', e);
    }
  };

  wsConnection.onclose = function(event) {
    wsConnected = false;
    wsStopPing();
    setWsStatus('disconnected');
    wsScheduleReconnect();
  };

  wsConnection.onerror = function() {
    console.error('WS connection error');
  };
}

function wsDisconnect() {
  if (wsConnection) {
    wsConnection.onclose = null;
    wsConnection.close();
    wsConnection = null;
  }
  wsConnected = false;
  wsStopPing();
}

function wsSend(data) {
  if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
    wsConnection.send(JSON.stringify(data));
  }
}

function wsStartPing() {
  wsStopPing();
  wsPingTimer = setInterval(function() { wsSend({ op: 'ping' }); }, WS_PING_INTERVAL);
}

function wsStopPing() {
  if (wsPingTimer) { clearInterval(wsPingTimer); wsPingTimer = null; }
}

function wsScheduleReconnect() {
  var delay = Math.min(
    WS_RECONNECT_BASE_MS * Math.pow(2, wsReconnectAttempts),
    WS_RECONNECT_MAX_MS
  );
  wsReconnectAttempts++;
  setWsStatus('reconnecting');
  console.log('WS reconnect in', delay, 'ms (attempt ' + wsReconnectAttempts + ')');

  // Start fallback REST polling after 3 failed reconnects
  if (wsReconnectAttempts >= 3 && !wsFallbackTimer) {
    console.log('WS offline — falling back to REST polling');
    wsFallbackTimer = setInterval(function() { fullRefresh(); }, REFRESH_INTERVAL);
  }

  setTimeout(wsConnect, delay);
}

function wsSubscribeAll() {
  var symbols = Object.keys(instruments);
  var topics = symbols.map(function(s) { return 'tickers.' + s; });
  for (var i = 0; i < topics.length; i += WS_SUB_BATCH) {
    wsSend({ op: 'subscribe', args: topics.slice(i, i + WS_SUB_BATCH) });
  }
  console.log('WS subscribed to', topics.length, 'ticker streams');
}

// ── Process real-time ticker updates ──

function processWsTicker(msg) {
  var data = msg.data;
  if (!data || !data.symbol) return;
  var sym = data.symbol;
  var inst = instruments[sym];
  if (!inst) return;

  // Update price with flash tracking
  if (data.lastPrice !== undefined) {
    var newPrice = parseFloat(data.lastPrice);
    if (!isNaN(newPrice) && newPrice !== inst.price) {
      previousPrices[sym] = inst.price;
      inst.price = newPrice;
    }
  }

  // Update ticker fields (delta messages only contain changed fields)
  if (data.highPrice24h !== undefined) inst.high24h = parseFloat(data.highPrice24h);
  if (data.lowPrice24h !== undefined) inst.low24h = parseFloat(data.lowPrice24h);
  if (data.price24hPcnt !== undefined) inst.change24h = parseFloat(data.price24hPcnt) * 100;
  if (data.turnover24h !== undefined) inst.volume24h = parseFloat(data.turnover24h);
  if (data.fundingRate !== undefined) inst.fundingRate = parseFloat(data.fundingRate);
  if (data.openInterest !== undefined) inst.openInterest = parseFloat(data.openInterest) * inst.price;

  // Recompute derived fields
  var rp = computePricePosition(inst.price, inst.high24h, inst.low24h);
  inst.rangePosition = rp.position;
  inst.rangeAbovePct = rp.abovePct;
  inst.rangeBelowPct = rp.belowPct;
  updateSignalFor(sym);

  // Throttled render
  dirtySymbols.add(sym);
  scheduleThrottledRender();
}

function scheduleThrottledRender() {
  if (renderThrottleTimer) return;
  renderThrottleTimer = setTimeout(function() {
    renderThrottleTimer = null;
    if (dirtySymbols.size > 0) {
      dirtySymbols.clear();
      renderTable();
      updateLastRefresh();
    }
  }, RENDER_THROTTLE_MS);
}

// ── WebSocket status display ──

function setWsStatus(state) {
  var dot = document.getElementById('statusDot');
  var text = document.getElementById('statusText');
  dot.classList.remove('loading', 'ws-live', 'ws-disconnected', 'ws-reconnecting');
  switch (state) {
    case 'connected':
      dot.classList.add('ws-live');
      text.textContent = 'Live \u2014 Streaming';
      break;
    case 'disconnected':
      dot.classList.add('ws-disconnected');
      text.textContent = 'Disconnected';
      break;
    case 'reconnecting':
      dot.classList.add('ws-reconnecting');
      text.textContent = 'Reconnecting...';
      break;
  }
}

// ============================================================
// Slow REST polls (indicators that have no WebSocket stream)
// ============================================================

async function pollKlineData() {
  try {
    var symbols = Object.keys(instruments);
    for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
      var batch = symbols.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(function(sym) { return loadKlineDataForSymbol(sym); }));
      if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
    }
    renderTable();
    saveCache();
  } catch (e) {
    console.warn('Kline poll error:', e.message);
  }
}

async function pollOIData() {
  try {
    var symbols = Object.keys(instruments);
    for (var i = 0; i < symbols.length; i += BATCH_SIZE) {
      var batch = symbols.slice(i, i + BATCH_SIZE);
      await Promise.all(batch.map(function(sym) { return loadAdditionalDataForSymbol(sym); }));
      if (i + BATCH_SIZE < symbols.length) await new Promise(function(r) { setTimeout(r, BATCH_DELAY); });
    }
    renderTable();
    saveCache();
  } catch (e) {
    console.warn('OI poll error:', e.message);
  }
}

function startIndicatorCountdown(intervalMs) {
  nextRefreshAt = Date.now() + intervalMs;
  if (countdownTimer) clearInterval(countdownTimer);
  countdownTimer = setInterval(function() {
    var remaining = Math.max(0, Math.ceil((nextRefreshAt - Date.now()) / 1000));
    var min = Math.floor(remaining / 60);
    var sec = remaining % 60;
    document.getElementById('nextRefresh').textContent =
      min > 0 ? min + ':' + (sec < 10 ? '0' : '') + sec : sec + 's';
    if (remaining <= 0) clearInterval(countdownTimer);
  }, 1000);
}

// ============================================================
// Init
// ============================================================

loadColumnPrefs();
buildHeader();
buildColumnPicker();

(async function init() {
  var hadCache = loadCache();
  if (hadCache) document.getElementById('loadingOverlay').classList.add('hidden');

  try {
    // Phase 1: Full REST bootstrap (tickers + all indicators)
    await fullRefresh();
    document.getElementById('loadingOverlay').classList.add('hidden');
  } catch (e) {
    if (!hadCache) {
      document.getElementById('loadingOverlay').textContent = 'Failed to load data: ' + e.message;
      document.getElementById('loadingOverlay').style.color = 'var(--red)';
    } else {
      setStatus('Refresh failed \u2014 showing cached data', false);
    }
  }

  // Phase 2: Start WebSocket for real-time ticker streaming
  wsConnect();

  // Phase 3: Slow REST polls for indicators (no WS stream available)
  klinePollTimer = setInterval(function() {
    pollKlineData();
    startIndicatorCountdown(KLINE_POLL_INTERVAL);
  }, KLINE_POLL_INTERVAL);

  oiPollTimer = setInterval(function() {
    pollOIData();
  }, OI_POLL_INTERVAL);

  startIndicatorCountdown(KLINE_POLL_INTERVAL);
})();
</script>
</body>
</html>
